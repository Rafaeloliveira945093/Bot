{"file_contents":{"README.md":{"content":"# Bot Telegram em Python\n\nBot completo para Telegram com menu interativo, cria√ß√£o de mensagens e reenvio autom√°tico.\n\n## üöÄ Configura√ß√£o Local\n\n### 1. Instalar Depend√™ncias\n```bash\npip install python-telegram-bot python-dotenv\n```\n\n### 2. Configurar Token\n**Op√ß√£o A - Arquivo .env (Recomendado):**\n```bash\n# Copie o arquivo de exemplo\ncp .env.example .env\n\n# Edite o arquivo .env e adicione seu token\n# BOT_TOKEN=1234567890:ABCDEFghijklmnopQRSTUVwxyz\n```\n\n**Op√ß√£o B - Vari√°vel de Ambiente:**\n```bash\n# Linux/Mac\nexport BOT_TOKEN=\"seu_token_aqui\"\n\n# Windows\nset BOT_TOKEN=seu_token_aqui\n```\n\n### 3. Executar o Bot\n```bash\npython main.py\n```\n\n## üîß Configura√ß√£o no Replit\n\n1. V√° no painel **Secrets** (√≠cone do cadeado)\n2. Adicione uma nova secret:\n   - **Key:** BOT_TOKEN\n   - **Value:** seu_token_do_telegram\n3. Execute o projeto\n\n## üì± Funcionalidades\n\n- ‚úÖ Menu interativo com 6 op√ß√µes\n- ‚úÖ Cria√ß√£o de mensagens com texto, m√≠dia e bot√µes\n- ‚úÖ Reenvio imediato de mensagens\n- ‚úÖ Cadastro de grupos de destino\n- ‚úÖ Suporte a todos os tipos de m√≠dia\n- ‚úÖ Sistema de navega√ß√£o intuitivo\n\n## üîí Seguran√ßa\n\n- Token protegido por vari√°veis de ambiente\n- Arquivo .env ignorado pelo Git\n- Configura√ß√£o flex√≠vel para desenvolvimento e produ√ß√£o\n\n\n","size_bytes":1283},"config.py":{"content":"import os\nfrom typing import Optional\n\n# Try to load .env file for local development\ntry:\n    from dotenv import load_dotenv\n    load_dotenv()\n    print(\"Arquivo .env carregado com sucesso\")\nexcept ImportError:\n    print(\"python-dotenv n√£o instalado, usando vari√°veis de ambiente do sistema\")\nexcept Exception as e:\n    print(f\"Aviso: N√£o foi poss√≠vel carregar .env: {e}\")\n\n# Bot configuration\nBOT_TOKEN: str = os.getenv(\"BOT_TOKEN\", \"\")\nif not BOT_TOKEN:\n    raise ValueError(\n        \"BOT_TOKEN n√£o encontrado. \"\n        \"Para uso local: crie um arquivo .env com BOT_TOKEN=seu_token \"\n        \"Para Replit: adicione BOT_TOKEN no painel Secrets\"\n    )\n\n# Group chat ID for posting messages\nGROUP_CHAT_ID: int = -1002869921534\n\n# Conversation states\nMENU_ENVIO = 0\nRECEBER_MIDIA = 1\nRECEBER_TEXTO = 2\nRECEBER_BOTOES = 3\nCONFIRMAR_PREVIA = 4\nEDITAR_ESCOLHA = 5\nMENU_REPASSAR = 6\nRECEBER_ENCAMINHADAS = 7\nRECEBER_LINK = 8\nCONFIRMAR_REPASSAR = 9\nEDITAR_REPASSAR = 10\nCADASTRAR_GRUPO = 11\nSELECIONAR_GRUPO = 12\nCONFIRMAR_GRUPO = 13\nMENU_PRINCIPAL = 14\n\nFORWARD_COLLECT = 100\n\n# New editing states for option 5\nMENU_EDICAO = 101\nADICIONAR_TEXTO = 102\nADICIONAR_BOTAO_TITULO = 103\nADICIONAR_BOTAO_LINK = 104\nREMOVER_PALAVRA = 105\nCONFIRMAR_EDICAO = 106\n\n# Message limits\nMAX_MESSAGE_LENGTH = 4096\nMAX_CAPTION_LENGTH = 1024\n\n# Storage for registered destination group\nDESTINATION_GROUP_KEY = \"destination_group_id\"\n","size_bytes":1413},"main.py":{"content":"import os\nimport logging\nfrom telegram.ext import ApplicationBuilder, ConversationHandler, CommandHandler, MessageHandler, CallbackQueryHandler, filters\nfrom config import BOT_TOKEN\nfrom handlers.message_handlers import (\n    start, receber_midia, receber_texto, receber_botoes, receber_encaminhadas,\n    receber_link, comando_pronto, handle_any_message, selecionar_grupo, processar_repassar_mensagem, voltar_menu_principal,\n    adicionar_texto_handler, adicionar_botao_titulo_handler, adicionar_botao_link_handler, remover_palavra_handler\n)\nfrom handlers.callback_handlers import (\n    button_handler, menu_envio_handler, confirmar_previa_handler,\n    editar_escolha_handler, encaminhamento_callback_handler, menu_edicao_handler,\n    global_callback_handler, handle_any_message\n)\n\n# Configure logging\nlogging.basicConfig(\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    level=logging.INFO\n)\nlogger = logging.getLogger(__name__)\n\n# Conversation states\n(MENU_ENVIO, RECEBER_MIDIA, RECEBER_TEXTO, RECEBER_BOTOES, \n CONFIRMAR_PREVIA, EDITAR_ESCOLHA, MENU_REPASSAR, RECEBER_ENCAMINHADAS, \n RECEBER_LINK, CONFIRMAR_REPASSAR, EDITAR_REPASSAR, CADASTRAR_GRUPO,\n SELECIONAR_GRUPO, CONFIRMAR_GRUPO, MENU_PRINCIPAL) = range(15)\n\nFORWARD_COLLECT = 100\n\n# New editing states for option 5\nMENU_EDICAO = 101\nADICIONAR_TEXTO = 102\nADICIONAR_BOTAO_TITULO = 103\nADICIONAR_BOTAO_LINK = 104\nREMOVER_PALAVRA = 105\nCONFIRMAR_EDICAO = 106\n\ndef main():\n    \"\"\"Start the bot with optimized async handlers.\"\"\"\n    # Create the Application with async optimization for real-time performance\n    application = (\n        ApplicationBuilder()\n        .token(BOT_TOKEN)\n        .concurrent_updates(True)  # Enable concurrent processing for faster response\n        .build()\n    )\n    \n    # Main conversation handler for message sending\n    envio_conversation = ConversationHandler(\n        entry_points=[CallbackQueryHandler(button_handler, pattern=\"^opcao4$\")],\n        states={\n            MENU_ENVIO: [CallbackQueryHandler(menu_envio_handler)],\n            RECEBER_MIDIA: [MessageHandler(filters.PHOTO | filters.VIDEO, receber_midia)],\n            RECEBER_TEXTO: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_texto)],\n            RECEBER_BOTOES: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_botoes)],\n            CONFIRMAR_PREVIA: [CallbackQueryHandler(confirmar_previa_handler)],\n            EDITAR_ESCOLHA: [CallbackQueryHandler(editar_escolha_handler)],\n        },\n        fallbacks=[CommandHandler(\"cancel\", start)],\n    )\n    \n    # Group registration conversation handler  \n    group_registration_conversation = ConversationHandler(\n        entry_points=[CallbackQueryHandler(button_handler, pattern=\"^opcao1$\")],\n        states={\n            SELECIONAR_GRUPO: [\n                MessageHandler(filters.TEXT & ~filters.COMMAND, selecionar_grupo),\n                CallbackQueryHandler(encaminhamento_callback_handler)\n            ],\n            CONFIRMAR_GRUPO: [\n                MessageHandler(filters.TEXT & ~filters.COMMAND, selecionar_grupo),\n                CallbackQueryHandler(encaminhamento_callback_handler)\n            ],\n        },\n        fallbacks=[CommandHandler(\"cancel\", start)],\n    )\n    \n    # Forwarding conversation handler with editing menu\n    forwarding_conversation = ConversationHandler(\n        entry_points=[CallbackQueryHandler(button_handler, pattern=\"^opcao5$\")],\n        states={\n            RECEBER_ENCAMINHADAS: [\n                MessageHandler(filters.ALL & ~filters.COMMAND, receber_encaminhadas)\n            ],\n            MENU_EDICAO: [\n                CallbackQueryHandler(menu_edicao_handler)\n            ],\n            ADICIONAR_TEXTO: [\n                MessageHandler(filters.TEXT & ~filters.COMMAND, adicionar_texto_handler)\n            ],\n            ADICIONAR_BOTAO_TITULO: [\n                MessageHandler(filters.TEXT & ~filters.COMMAND, adicionar_botao_titulo_handler)\n            ],\n            ADICIONAR_BOTAO_LINK: [\n                MessageHandler(filters.TEXT & ~filters.COMMAND, adicionar_botao_link_handler)\n            ],\n            REMOVER_PALAVRA: [\n                MessageHandler(filters.TEXT & ~filters.COMMAND, remover_palavra_handler)\n            ],\n            CONFIRMAR_EDICAO: [\n                CallbackQueryHandler(menu_edicao_handler)\n            ],\n            FORWARD_COLLECT: [\n                MessageHandler(filters.ALL & ~filters.COMMAND, receber_encaminhadas),\n                CallbackQueryHandler(encaminhamento_callback_handler)\n            ],\n        },\n        fallbacks=[CommandHandler(\"cancel\", start)],\n    )\n    \n    # Add handlers\n    application.add_handler(CommandHandler(\"start\", start))\n    application.add_handler(envio_conversation)\n    application.add_handler(group_registration_conversation)\n    application.add_handler(forwarding_conversation)\n    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, start))\n    \n    # Option 5 is handled by forwarding_conversation\n    \n    # Handle \"voltar_menu\" callback from any conversation\n    from handlers.message_handlers import voltar_menu_principal\n    application.add_handler(CallbackQueryHandler(voltar_menu_principal, pattern=\"^voltar_menu$\"))\n    \n    # Add global callback handler for menu buttons outside conversations\n    from handlers.callback_handlers import global_callback_handler\n    application.add_handler(CallbackQueryHandler(global_callback_handler))\n    \n    # Handle any other message - always show menu (unless in active conversation)\n    application.add_handler(MessageHandler(filters.ALL & ~filters.COMMAND, handle_any_message))\n    \n    # Start a simple health check web server on port 5000 in background\n    import threading\n    import json\n    from http.server import HTTPServer, BaseHTTPRequestHandler\n    \n    class HealthCheckHandler(BaseHTTPRequestHandler):\n        def do_GET(self):\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            response = {\n                \"status\": \"running\",\n                \"bot\": \"Telegram Bot Server\", \n                \"message\": \"Bot is active and processing messages\"\n            }\n            self.wfile.write(json.dumps(response).encode())\n            \n        def log_message(self, format, *args):\n            # Suppress HTTP server logs\n            pass\n    \n    # Start web server in background thread\n    def start_web_server():\n        server = HTTPServer((\"0.0.0.0\", 5000), HealthCheckHandler)\n        server.serve_forever()\n    \n    web_thread = threading.Thread(target=start_web_server, daemon=True)\n    web_thread.start()\n    logger.info(\"Health check web server started on port 5000\")\n    \n    # Run bot with optimized polling for real-time performance\n    application.run_polling(\n        poll_interval=0.1,  # Faster polling (check every 0.1 seconds)\n        timeout=10,         # Shorter timeout for more responsive updates\n        allowed_updates=[\"message\", \"callback_query\"],\n        drop_pending_updates=True  # Drop old updates for faster response\n    )\n\nif __name__ == '__main__':\n    main()\n","size_bytes":7142},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"python-dotenv>=1.1.1\",\n    \"python-telegram-bot==20.8\",\n    \"telegram>=0.0.1\",\n]\n","size_bytes":228},"replit.md":{"content":"# Overview\nThis project is a Python-based Telegram bot designed to streamline communication and content distribution. It provides a menu-driven interface for users to send messages (text, media, buttons) to group chats, manage automatic message forwarding to registered groups, and handle group registrations. The bot aims to simplify content management and automate message distribution, offering a robust solution for diverse communication needs.\n\n# User Preferences\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n## Core Bot Framework\n- **Framework**: Built on `python-telegram-bot` using `Application` and `ConversationHandler` patterns.\n- **State Management**: Utilizes conversation states for tracking multi-exchange user interactions.\n- **Modular Design**: Structured into distinct modules (handlers, utils, config) for maintainability.\n\n## Conversation Flow Architecture\n- **Main Menu System**: Six primary options via inline keyboard buttons.\n- **State-Based Navigation**: Implements 14 conversation states for complex multi-step interactions.\n- **Conversation Handlers**: Three main flows: message sending, group registration, and message forwarding.\n- **Automatic Message Processing**: Messages sent to the bot are automatically forwarded to registered destination groups.\n- **Fallback Mechanisms**: Includes cancel commands and error handling.\n\n## Message Processing System\n- **Multi-Format Support**: Handles text, photos, videos, documents, audio, voice, stickers, animations, and inline buttons.\n- **Content Validation**: Validates button formats, URLs, and message content.\n- **Media Handling**: Processes all media types with file ID tracking, preserving captions and entities.\n- **Button Generation**: Creates inline keyboards from user-provided text.\n- **Automatic Forwarding**: Copies messages preserving all original content (formatting, media, captions, buttons).\n- **Group Management**: Allows registration, testing, and management of multiple destination groups.\n- **Bulk Message Workflow**: Supports collecting multiple messages for bulk editing and sending, preserving Telegram formatting and entities.\n\n## Error Handling and Logging\n- **Logging**: Uses Python's logging module for debugging and monitoring.\n- **Exception Management**: Try-catch blocks with user-friendly error messages.\n- **Input Validation**: Validates user inputs to prevent errors.\n\n## Configuration Management\n- **Environment Variables**: Bot token and sensitive configuration stored as environment variables.\n- **Constants**: Centralized configuration for conversation states and message limits.\n- **Persistent Storage**: JSON file storage for destination group configuration and user data.\n- **Type Safety**: Uses type hints throughout the codebase.\n\n## UI/UX Decisions\n- **Intuitive Menu Structure**: Clear hierarchy from main menu to specific actions.\n- **Visual Feedback**: Progress indicators and confirmation messages.\n- **Flexible Group Removal**: Easy group deletion with confirmation prompts.\n- **Success Tracking**: Detailed feedback on message delivery.\n- **Return to Menu**: \"Voltar ao Menu Principal\" button at the end of functions.\n\n## System Design Choices\n- **Private Chat Only**: Bot ignores messages in group chats, operating only in private chats.\n- **Secure Group Access**: Validates bot access to groups during registration.\n- **User Data Isolation**: Each user maintains a separate group list.\n- **Multi-Destination Group System**: Supports sending messages to multiple selected groups simultaneously.\n- **Seamless Group Registration**: Groups are automatically added after successful test message without confirmation prompts.\n- **Automatic Menu Return**: Main menu appears automatically after group operations without user action required.\n- **Always Responsive Interface**: Any message from user triggers main menu display for continuous interaction.\n\n# External Dependencies\n- **Telegram Bot API**:\n    - `python-telegram-bot`: Primary library for bot functionality.\n    - `BOT_TOKEN`: Environment variable for authentication.\n    - `GROUP_CHAT_ID`: Configured for sending messages to a specific group chat.\n- **Python Standard Library**:\n    - `os`: For environment variable access.\n    - `logging`: For application logging and debugging.\n    - `re`: For regular expression validation.\n    - `typing`: For type hints.\n- **File System**:\n    - `bot_data.json`: Local JSON file for persistent data storage (e.g., destination group settings).\n- **Web Server**:\n    - Python's built-in `HTTPServer`: For HTTP health checks on port 5000.","size_bytes":4592},"attached_assets/main_1755388773463.py":{"content":"from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import (\n    ApplicationBuilder, CommandHandler, ContextTypes, CallbackQueryHandler,\n    ConversationHandler, MessageHandler, filters\n)\n\nGROUP_CHAT_ID = -1002869921534  \n\nMENU_ENVIO, RECEBER_MIDIA, RECEBER_TEXTO, RECEBER_BOTOES, CONFIRMAR_PREVIA, EDITAR_ESCOLHA, MENU_REPASSAR, RECEBER_ENCAMINHADAS, RECEBER_LINK, CONFIRMAR_REPASSAR, EDITAR_REPASSAR = range(11)\nFORWARD_COLLECT, RECEBER_LINK, CONFIRMAR_REPASSAR, EDITAR_REPASSAR = 100, 101, 102, 103\n\nasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    keyboard = [\n        [InlineKeyboardButton(\"1 ‚Äì Grupos e canais\", callback_data=\"opcao1\")],\n        [InlineKeyboardButton(\"2 ‚Äì Lista de cursos\", callback_data=\"opcao2\")],\n        [InlineKeyboardButton(\"3 ‚Äì Grupo VIP\", callback_data=\"opcao3\")],\n        [InlineKeyboardButton(\"4 ‚Äì Enviar mensagem\", callback_data=\"opcao4\")],\n        [InlineKeyboardButton(\"5 ‚Äì Repassar mensagens encaminhadas\", callback_data=\"opcao5\")]\n    ]\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    # Envia boas-vindas sempre que receber qualquer mensagem\n    await update.message.reply_text(\"Escolha uma op√ß√£o:\", reply_markup=reply_markup)\n\nasync def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    query = update.callback_query\n    await query.answer()\n    if query.data == \"opcao1\":\n        await query.edit_message_text(\"Voc√™ selecionou: Grupos e canais\")\n    elif query.data == \"opcao2\":\n        await query.edit_message_text(\"Voc√™ selecionou: Lista de cursos\")\n    elif query.data == \"opcao3\":\n        await query.edit_message_text(\"Voc√™ selecionou: Grupo VIP\")\n    elif query.data == \"opcao4\":\n        keyboard = [\n            [InlineKeyboardButton(\"M√çDIA\", callback_data=\"midia\")],\n            [InlineKeyboardButton(\"TEXTO\", callback_data=\"texto\")],\n            [InlineKeyboardButton(\"BOT√ïES\", callback_data=\"botoes\")],\n            [InlineKeyboardButton(\"INICIAR\", callback_data=\"iniciar\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        await query.edit_message_text(\"Escolha o tipo de conte√∫do ou clique em INICIAR para come√ßar:\", reply_markup=reply_markup)\n        return MENU_ENVIO\n    elif query.data == \"opcao5\":\n        context.user_data[\"encaminhadas\"] = []\n        context.user_data[\"menu_msg_id\"] = None\n        await query.edit_message_text(\"Encaminhe uma ou mais mensagens para este chat.\")\n        await mostrar_menu_encaminhamento(update, context)\n        return RECEBER_ENCAMINHADAS\n    return ConversationHandler.END\n\nasync def menu_envio_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    query = update.callback_query\n    await query.answer()\n    if query.data == \"midia\":\n        await query.edit_message_text(\"Voc√™ selecionou: M√çDIA.\")\n        return MENU_ENVIO\n    elif query.data == \"texto\":\n        await query.edit_message_text(\"Voc√™ selecionou: TEXTO.\")\n        return MENU_ENVIO\n    elif query.data == \"botoes\":\n        await query.edit_message_text(\"Voc√™ selecionou: BOT√ïES.\")\n        return MENU_ENVIO\n    elif query.data == \"iniciar\":\n        await query.edit_message_text(\"Envie a m√≠dia (foto ou v√≠deo) que deseja postar:\")\n        return RECEBER_MIDIA\n\nasync def receber_midia(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    if update.message.photo:\n        file_id = update.message.photo[-1].file_id\n        context.user_data[\"midia\"] = (\"photo\", file_id)\n    elif update.message.video:\n        file_id = update.message.video.file_id\n        context.user_data[\"midia\"] = (\"video\", file_id)\n    else:\n        await update.message.reply_text(\"Por favor, envie uma foto ou v√≠deo.\")\n        return RECEBER_MIDIA\n    await update.message.reply_text(\"Agora envie o texto da mensagem:\")\n    return RECEBER_TEXTO\n\nasync def receber_texto(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    context.user_data[\"texto\"] = update.message.text\n    await update.message.reply_text(\n        \"Agora envie os bot√µes no formato:\\n\\nNOME1|LINK1, NOME2|LINK2\\n\\nExemplo:\\nVIP|https://t.me/grupovip, Cursos|https://t.me/cursos\"\n    )\n    return RECEBER_BOTOES\n\nasync def receber_botoes(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    texto = update.message.text\n    botoes = []\n    partes = [b.strip() for b in texto.split(\",\") if b.strip()]\n    erro = False\n    for parte in partes:\n        if \"|\" in parte:\n            nome, link = parte.split(\"|\", 1)\n            nome = nome.strip()\n            link = link.strip()\n            if nome and link:\n                botoes.append((nome, link))\n            else:\n                erro = True\n        else:\n            erro = True\n    if erro or not botoes:\n        await update.message.reply_text(\n            \"Formato inv√°lido. Envie os bot√µes como: NOME|LINK, NOME2|LINK2\"\n        )\n        return RECEBER_BOTOES\n    context.user_data[\"botoes\"] = botoes\n    await mostrar_previa(update, context)\n    return CONFIRMAR_PREVIA\n\nasync def mostrar_previa(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    midia = context.user_data.get(\"midia\")\n    texto = context.user_data.get(\"texto\", \"\")\n    botoes = context.user_data.get(\"botoes\", [])\n    reply_markup = None\n    if botoes:\n        reply_markup = InlineKeyboardMarkup(\n            [[InlineKeyboardButton(nome, url=link)] for nome, link in botoes]\n        )\n    # Envia a pr√©via exatamente como ser√° publicada no grupo\n    if midia:\n        tipo, file_id = midia\n        if tipo == \"photo\":\n            await update.message.reply_photo(photo=file_id, caption=texto, reply_markup=reply_markup)\n        elif tipo == \"video\":\n            await update.message.reply_video(video=file_id, caption=texto, reply_markup=reply_markup)\n    else:\n        await update.message.reply_text(texto, reply_markup=reply_markup)\n    # Logo abaixo, exibe o menu de confirma√ß√£o/edi√ß√£o\n    keyboard = [\n        [InlineKeyboardButton(\"Confirmar\", callback_data=\"sim\")],\n        [InlineKeyboardButton(\"Editar\", callback_data=\"editar\")]\n    ]\n    reply_markup_confirm = InlineKeyboardMarkup(keyboard)\n    await update.message.reply_text(\"Est√° correto?\", reply_markup=reply_markup_confirm)\n\nasync def confirmar_previa_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    query = update.callback_query\n    await query.answer()\n    if query.data == \"sim\":\n        midia = context.user_data.get(\"midia\")\n        texto = context.user_data.get(\"texto\", \"\")\n        botoes = context.user_data.get(\"botoes\", [])\n        reply_markup = None\n        if botoes:\n            reply_markup = InlineKeyboardMarkup(\n                [[InlineKeyboardButton(nome, url=link)] for nome, link in botoes]\n            )\n        if midia:\n            tipo, file_id = midia\n            if tipo == \"photo\":\n                await context.bot.send_photo(chat_id=GROUP_CHAT_ID, photo=file_id, caption=texto, reply_markup=reply_markup)\n            elif tipo == \"video\":\n                await context.bot.send_video(chat_id=GROUP_CHAT_ID, video=file_id, caption=texto, reply_markup=reply_markup)\n        else:\n            await context.bot.send_message(chat_id=GROUP_CHAT_ID, text=texto, reply_markup=reply_markup)\n        await query.edit_message_text(\"Mensagem enviada ao grupo com sucesso!\")\n        return ConversationHandler.END\n    elif query.data == \"editar\":\n        keyboard = [\n            [InlineKeyboardButton(\"M√çDIA\", callback_data=\"editar_midia\")],\n            [InlineKeyboardButton(\"TEXTO\", callback_data=\"editar_texto\")],\n            [InlineKeyboardButton(\"BOT√ïES\", callback_data=\"editar_botoes\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        await query.edit_message_text(\"Qual parte deseja editar?\", reply_markup=reply_markup)\n        return EDITAR_ESCOLHA\n\nasync def editar_escolha_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    query = update.callback_query\n    await query.answer()\n    if query.data == \"editar_midia\":\n        await query.edit_message_text(\"Envie a nova m√≠dia (foto ou v√≠deo):\")\n        return RECEBER_MIDIA\n    elif query.data == \"editar_texto\":\n        await query.edit_message_text(\"Envie o novo texto:\")\n        return RECEBER_TEXTO\n    elif query.data == \"editar_botoes\":\n        await query.edit_message_text(\n            \"Envie os novos bot√µes no formato:\\nNOME|LINK, NOME2|LINK2\"\n        )\n        return RECEBER_BOTOES\n\nasync def mostrar_menu_encaminhamento(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    keyboard = [\n        [InlineKeyboardButton(\"Adicionar mais mensagens\", callback_data=\"add_msgs\")],\n        [InlineKeyboardButton(\"Finalizar\", callback_data=\"finalizar_encaminhamento\")],\n        [InlineKeyboardButton(\"Cancelar\", callback_data=\"cancelar_encaminhamento\")]\n    ]\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    # Envia ou atualiza o menu fixo\n    if context.user_data.get(\"menu_msg_id\"):\n        try:\n            await update.effective_chat.edit_message_reply_markup(\n                message_id=context.user_data[\"menu_msg_id\"],\n                reply_markup=reply_markup\n            )\n        except Exception:\n            pass\n    else:\n        msg = await update.effective_chat.send_message(\n            \"Quando terminar, clique em Finalizar.\\nPara cancelar, clique em Cancelar.\",\n            reply_markup=reply_markup\n        )\n        context.user_data[\"menu_msg_id\"] = msg.message_id\n\n# Utilit√°rio para atualizar o menu fixo\nasync def atualizar_menu_encaminhamento(context, chat_id, menu_msg_id, total):\n    keyboard = [\n        [InlineKeyboardButton(f\"Adicionar mais mensagens\", callback_data=\"add_msgs\")],\n        [InlineKeyboardButton(f\"Finalizar ({total} coletados)\", callback_data=\"finalizar_encaminhamento\")],\n        [InlineKeyboardButton(\"Cancelar\", callback_data=\"cancelar_encaminhamento\")]\n    ]\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    try:\n        await context.bot.edit_message_reply_markup(\n            chat_id=chat_id,\n            message_id=menu_msg_id,\n            reply_markup=reply_markup\n        )\n    except Exception:\n        pass\n\n# Handler para coletar mensagens encaminhadas:\nasync def receber_encaminhadas(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    msg = update.message\n    # Inicializa lista de itens e grupos\n    context.user_data.setdefault(\"forwarded_items\", [])\n    context.user_data.setdefault(\"media_groups\", {})\n    # Media group (√°lbum)\n    if msg.media_group_id:\n        group_id = msg.media_group_id\n        context.user_data[\"media_groups\"].setdefault(group_id, []).append(msg)\n        # Aguarda mais itens do grupo (Telegram envia em sequ√™ncia)\n        # S√≥ registra quando n√£o vier mais do mesmo grupo (tratado no menu)\n    else:\n        # Conte√∫do protegido\n        if getattr(msg, \"is_protected_content\", False):\n            await msg.reply_text(\"Conte√∫do protegido contra c√≥pia. Encaminhe outro item.\")\n            return FORWARD_COLLECT\n        context.user_data[\"forwarded_items\"].append(msg)\n    # Atualiza menu fixo\n    total = len(context.user_data[\"forwarded_items\"]) + sum(len(g) for g in context.user_data[\"media_groups\"].values())\n    if not context.user_data.get(\"menu_msg_id\"):\n        menu = await msg.reply_text(\n            f\"Encaminhe mensagens. Quando terminar, clique em Finalizar.\\nItens coletados: {total}\",\n            reply_markup=InlineKeyboardMarkup([\n                [InlineKeyboardButton(\"Adicionar mais mensagens\", callback_data=\"add_msgs\")],\n                [InlineKeyboardButton(f\"Finalizar ({total} coletados)\", callback_data=\"finalizar_encaminhamento\")],\n                [InlineKeyboardButton(\"Cancelar\", callback_data=\"cancelar_encaminhamento\")]\n            ])\n        )\n        context.user_data[\"menu_msg_id\"] = menu.message_id\n    else:\n        await atualizar_menu_encaminhamento(context, msg.chat_id, context.user_data[\"menu_msg_id\"], total)\n    return FORWARD_COLLECT\n\nasync def comando_pronto(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    if not context.user_data.get(\"encaminhadas\"):\n        await update.message.reply_text(\"Voc√™ n√£o encaminhou nenhuma mensagem. Encaminhe ao menos uma antes de digitar /pronto.\")\n        return RECEBER_ENCAMINHADAS\n    await update.message.reply_text(\"Agora envie o link de destino (grupo, canal ou chat):\")\n    return RECEBER_LINK  # <-- AVAN√áA PARA O PR√ìXIMO ESTADO\n\n# Handler para coletar o link de destino:\nasync def receber_link(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    link = update.message.text.strip()\n    # Valida√ß√£o simples: t.me/username ou chat_id\n    if link.startswith(\"t.me/\"):\n        await update.message.reply_text(\"Por favor, pe√ßa para o destino enviar uma mensagem para o bot ou informe o @username ou chat_id.\")\n        return RECEBER_LINK\n    context.user_data[\"destino\"] = link\n    await mostrar_previa_repassar(update, context)\n    return CONFIRMAR_REPASSAR\n\n# Fun√ß√£o para mostrar a pr√©via das mensagens encaminhadas:\nasync def mostrar_previa_repassar(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    items = context.user_data.get(\"forwarded_items\", [])\n    destino = context.user_data.get(\"destino\", \"\")\n    preview = f\"Pr√©via do repasse para: {destino}\\n\\n\"\n    for idx, item in enumerate(items, 1):\n        if isinstance(item, list):  # Media group\n            preview += f\"{idx}. [√Ålbum com {len(item)} m√≠dias]\\n\"\n            for m in item:\n                if m.photo:\n                    preview += \"   - Foto\\n\"\n                elif m.video:\n                    preview += \"   - V√≠deo\\n\"\n                elif m.document:\n                    preview += \"   - Documento\\n\"\n                elif m.audio:\n                    preview += \"   - √Åudio\\n\"\n                elif m.voice:\n                    preview += \"   - Voz\\n\"\n                elif m.sticker:\n                    preview += \"   - Sticker\\n\"\n                if m.caption:\n                    preview += f\"     Legenda: {m.caption}\\n\"\n        else:\n            if item.text:\n                preview += f\"{idx}. Texto: {item.text}\\n\"\n            elif item.photo:\n                preview += f\"{idx}. Foto\\n\"\n                if item.caption:\n                    preview += f\"   Legenda: {item.caption}\\n\"\n            elif item.video:\n                preview += f\"{idx}. V√≠deo\\n\"\n                if item.caption:\n                    preview += f\"   Legenda: {item.caption}\\n\"\n            elif item.document:\n                preview += f\"{idx}. Documento\\n\"\n                if item.caption:\n                    preview += f\"   Legenda: {item.caption}\\n\"\n            elif item.audio:\n                preview += f\"{idx}. √Åudio\\n\"\n                if item.caption:\n                    preview += f\"   Legenda: {item.caption}\\n\"\n            elif item.voice:\n                preview += f\"{idx}. Voz\\n\"\n            elif item.sticker:\n                preview += f\"{idx}. Sticker\\n\"\n    await update.message.reply_text(preview)\n    keyboard = [\n        [InlineKeyboardButton(\"Confirmar\", callback_data=\"confirmar_repassar\")],\n        [InlineKeyboardButton(\"Editar\", callback_data=\"editar_repassar\")]\n    ]\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    await update.message.reply_text(\"Est√° correto?\", reply_markup=reply_markup)\n\n# Handler para confirma√ß√£o ou edi√ß√£o:\nasync def confirmar_repassar_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    query = update.callback_query\n    await query.answer()\n\n    if query.data == \"confirmar_repassar\":\n        destino = context.user_data.get(\"destino\")\n        items = context.user_data.get(\"forwarded_items\", [])\n\n        if not destino:\n            await query.message.reply_text(\"Destino n√£o definido. Envie novamente o link ou chat_id.\")\n            return RECEBER_LINK\n\n        enviados = 0  # Contador de itens enviados\n\n        for item in items:\n            if isinstance(item, list):  # Media group\n                media_objs = []\n                for m in item:\n                    if getattr(m, \"is_protected_content\", False):\n                        continue  # Ignora m√≠dias protegidas\n                    if m.photo:\n                        media_objs.append(InputMediaPhoto(media=m.photo[-1].file_id, caption=m.caption or \"\"))\n                    elif m.video:\n                        media_objs.append(InputMediaVideo(media=m.video.file_id, caption=m.caption or \"\"))\n                    elif m.document:\n                        media_objs.append(InputMediaDocument(media=m.document.file_id, caption=m.caption or \"\"))\n                if media_objs:\n                    try:\n                        await query.bot.send_media_group(chat_id=destino, media=media_objs)\n                        enviados += len(media_objs)\n                    except Exception:\n                        await query.message.reply_text(\n                            \"N√£o foi poss√≠vel enviar um dos √°lbuns. Verifique se o destino √© v√°lido.\"\n                        )\n            else:\n                if getattr(item, \"is_protected_content\", False):\n                    continue  # Ignora itens protegidos\n                try:\n                    await item.copy_to(chat_id=destino)\n                    enviados += 1\n                except Exception:\n                    await query.message.reply_text(\n                        \"N√£o foi poss√≠vel copiar um dos itens. Verifique se o destino √© v√°lido.\"\n                    )\n\n        if enviados > 0:\n            await query.edit_message_text(f\"Mensagens repassadas com sucesso! ({enviados} itens enviados)\")\n        else:\n            await query.edit_message_text(\"Nenhum item p√¥de ser repassado. Todos eram protegidos ou o destino √© inv√°lido.\")\n\n        return ConversationHandler.END\n\n    elif query.data == \"editar_repassar\":\n        keyboard = [\n            [InlineKeyboardButton(\"Alterar link de destino\", callback_data=\"editar_link\")],\n            [InlineKeyboardButton(\"Remover todos os itens\", callback_data=\"editar_msgs\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        await query.edit_message_text(\"O que deseja editar?\", reply_markup=reply_markup)\n        return EDITAR_REPASSAR\n\n\n# Handler para edi√ß√£o:\nasync def editar_repassar_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    query = update.callback_query\n    await query.answer()\n    if query.data == \"editar_link\":\n        await query.edit_message_text(\"Envie o novo link de destino:\")\n        return RECEBER_LINK\n    elif query.data == \"editar_msgs\":\n        context.user_data[\"forwarded_items\"] = []\n        await query.edit_message_text(\"Encaminhe novamente as mensagens para este chat. Clique em Finalizar quando terminar.\")\n        return FORWARD_COLLECT\n\nasync def confirmar_conexao(app):\n    bot_info = await app.bot.get_me()\n    print(f\"Bot [{bot_info.first_name}] conectado com sucesso e online.\")\n\nasync def menu_encaminhamento_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    query = update.callback_query\n    await query.answer()\n    total = len(context.user_data.get(\"forwarded_items\", [])) + sum(len(g) for g in context.user_data.get(\"media_groups\", {}).values())\n    if query.data == \"add_msgs\":\n        await query.edit_message_reply_markup(reply_markup=query.message.reply_markup)\n        await query.message.reply_text(\"Continue encaminhando mensagens para este chat.\")\n        return FORWARD_COLLECT\n    elif query.data == \"finalizar_encaminhamento\":\n        # Finaliza media groups (adiciona todos como conjuntos)\n        for group in context.user_data.get(\"media_groups\", {}).values():\n            context.user_data[\"forwarded_items\"].append(group)\n        context.user_data[\"media_groups\"] = {}\n        if not context.user_data.get(\"forwarded_items\"):\n            await query.message.reply_text(\"Voc√™ n√£o encaminhou nenhuma mensagem. Encaminhe ao menos uma antes de finalizar.\")\n            return FORWARD_COLLECT\n        # Remove menu fixo\n        try:\n            await query.message.edit_reply_markup(reply_markup=None)\n        except Exception:\n            pass\n        context.user_data[\"menu_msg_id\"] = None\n        await query.message.reply_text(\"Agora envie o link de destino (grupo, canal ou chat):\")\n        return RECEBER_LINK\n    elif query.data == \"cancelar_encaminhamento\":\n        try:\n            await query.message.edit_reply_markup(reply_markup=None)\n        except Exception:\n            pass\n        context.user_data[\"menu_msg_id\"] = None\n        context.user_data[\"forwarded_items\"] = []\n        context.user_data[\"media_groups\"] = {}\n        await query.message.reply_text(\"Processo cancelado. Voltando ao menu principal.\")\n        return ConversationHandler.END\n\ndef main() -> None:\n    token = input(\"Digite o token do bot do Telegram: \").strip()\n    app = ApplicationBuilder().token(token).post_init(confirmar_conexao).build()\n    conv_handler = ConversationHandler(\n    entry_points=[CallbackQueryHandler(button_handler, pattern=\"^opcao4$|^opcao5$\")],\n    states={\n        # Menu de envio de m√≠dia/texto/bot√µes\n        MENU_ENVIO: [\n            CallbackQueryHandler(menu_envio_handler, pattern=\"^(midia|texto|botoes|iniciar)$\")\n        ],\n        RECEBER_MIDIA: [\n            MessageHandler(filters.PHOTO | filters.VIDEO, receber_midia)\n        ],\n        RECEBER_TEXTO: [\n            MessageHandler(filters.TEXT & ~filters.COMMAND, receber_texto)\n        ],\n        RECEBER_BOTOES: [\n            MessageHandler(filters.TEXT & ~filters.COMMAND, receber_botoes)\n        ],\n        CONFIRMAR_PREVIA: [\n            CallbackQueryHandler(confirmar_previa_handler, pattern=\"^(sim|editar)$\")\n        ],\n        EDITAR_ESCOLHA: [\n            CallbackQueryHandler(editar_escolha_handler, pattern=\"^editar_(midia|texto|botoes)$\")\n        ],\n\n        # Menu de encaminhamento de mensagens\n        RECEBER_ENCAMINHADAS: [\n            MessageHandler(filters.FORWARDED & ~filters.COMMAND, receber_encaminhadas)\n        ],\n        FORWARD_COLLECT: [\n            MessageHandler(filters.FORWARDED & ~filters.COMMAND, receber_encaminhadas),\n            CallbackQueryHandler(menu_encaminhamento_handler,\n                                 pattern=\"^(add_msgs|finalizar_encaminhamento|cancelar_encaminhamento)$\")\n        ],\n        RECEBER_LINK: [\n            MessageHandler(filters.TEXT & ~filters.COMMAND, receber_link)\n        ],\n        CONFIRMAR_REPASSAR: [\n            CallbackQueryHandler(confirmar_repassar_handler, pattern=\"^(confirmar_repassar|editar_repassar)$\")\n        ],\n        EDITAR_REPASSAR: [\n            CallbackQueryHandler(editar_repassar_handler, pattern=\"^(editar_link|editar_msgs)$\")\n        ]\n    },\n    fallbacks=[]\n)\n\n    app.add_handler(CallbackQueryHandler(button_handler, pattern=\"^(opcao1|opcao2|opcao3)$\"))\n    app.add_handler(conv_handler)\n    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, start))\n    app.run_polling()\n\nif __name__ == '__main__':\n    main()","size_bytes":23017},"attached_assets/main_1755388961092.py":{"content":"from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import (\n    ApplicationBuilder, CommandHandler, ContextTypes, CallbackQueryHandler,\n    ConversationHandler, MessageHandler, filters\n)\n\nGROUP_CHAT_ID = -1002869921534  \n\nMENU_ENVIO, RECEBER_MIDIA, RECEBER_TEXTO, RECEBER_BOTOES, CONFIRMAR_PREVIA, EDITAR_ESCOLHA, MENU_REPASSAR, RECEBER_ENCAMINHADAS, RECEBER_LINK, CONFIRMAR_REPASSAR, EDITAR_REPASSAR = range(11)\nFORWARD_COLLECT, RECEBER_LINK, CONFIRMAR_REPASSAR, EDITAR_REPASSAR = 100, 101, 102, 103\n\nasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    keyboard = [\n        [InlineKeyboardButton(\"1 ‚Äì Grupos e canais\", callback_data=\"opcao1\")],\n        [InlineKeyboardButton(\"2 ‚Äì Lista de cursos\", callback_data=\"opcao2\")],\n        [InlineKeyboardButton(\"3 ‚Äì Grupo VIP\", callback_data=\"opcao3\")],\n        [InlineKeyboardButton(\"4 ‚Äì Enviar mensagem\", callback_data=\"opcao4\")],\n        [InlineKeyboardButton(\"5 ‚Äì Repassar mensagens encaminhadas\", callback_data=\"opcao5\")]\n    ]\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    # Envia boas-vindas sempre que receber qualquer mensagem\n    await update.message.reply_text(\"Escolha uma op√ß√£o:\", reply_markup=reply_markup)\n\nasync def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    query = update.callback_query\n    await query.answer()\n    if query.data == \"opcao1\":\n        await query.edit_message_text(\"Voc√™ selecionou: Grupos e canais\")\n    elif query.data == \"opcao2\":\n        await query.edit_message_text(\"Voc√™ selecionou: Lista de cursos\")\n    elif query.data == \"opcao3\":\n        await query.edit_message_text(\"Voc√™ selecionou: Grupo VIP\")\n    elif query.data == \"opcao4\":\n        keyboard = [\n            [InlineKeyboardButton(\"M√çDIA\", callback_data=\"midia\")],\n            [InlineKeyboardButton(\"TEXTO\", callback_data=\"texto\")],\n            [InlineKeyboardButton(\"BOT√ïES\", callback_data=\"botoes\")],\n            [InlineKeyboardButton(\"INICIAR\", callback_data=\"iniciar\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        await query.edit_message_text(\"Escolha o tipo de conte√∫do ou clique em INICIAR para come√ßar:\", reply_markup=reply_markup)\n        return MENU_ENVIO\n    elif query.data == \"opcao5\":\n        context.user_data[\"encaminhadas\"] = []\n        context.user_data[\"menu_msg_id\"] = None\n        await query.edit_message_text(\"Encaminhe uma ou mais mensagens para este chat.\")\n        await mostrar_menu_encaminhamento(update, context)\n        return RECEBER_ENCAMINHADAS\n    return ConversationHandler.END\n\nasync def menu_envio_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    query = update.callback_query\n    await query.answer()\n    if query.data == \"midia\":\n        await query.edit_message_text(\"Voc√™ selecionou: M√çDIA.\")\n        return MENU_ENVIO\n    elif query.data == \"texto\":\n        await query.edit_message_text(\"Voc√™ selecionou: TEXTO.\")\n        return MENU_ENVIO\n    elif query.data == \"botoes\":\n        await query.edit_message_text(\"Voc√™ selecionou: BOT√ïES.\")\n        return MENU_ENVIO\n    elif query.data == \"iniciar\":\n        await query.edit_message_text(\"Envie a m√≠dia (foto ou v√≠deo) que deseja postar:\")\n        return RECEBER_MIDIA\n\nasync def receber_midia(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    if update.message.photo:\n        file_id = update.message.photo[-1].file_id\n        context.user_data[\"midia\"] = (\"photo\", file_id)\n    elif update.message.video:\n        file_id = update.message.video.file_id\n        context.user_data[\"midia\"] = (\"video\", file_id)\n    else:\n        await update.message.reply_text(\"Por favor, envie uma foto ou v√≠deo.\")\n        return RECEBER_MIDIA\n    await update.message.reply_text(\"Agora envie o texto da mensagem:\")\n    return RECEBER_TEXTO\n\nasync def receber_texto(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    context.user_data[\"texto\"] = update.message.text\n    await update.message.reply_text(\n        \"Agora envie os bot√µes no formato:\\n\\nNOME1|LINK1, NOME2|LINK2\\n\\nExemplo:\\nVIP|https://t.me/grupovip, Cursos|https://t.me/cursos\"\n    )\n    return RECEBER_BOTOES\n\nasync def receber_botoes(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    texto = update.message.text\n    botoes = []\n    partes = [b.strip() for b in texto.split(\",\") if b.strip()]\n    erro = False\n    for parte in partes:\n        if \"|\" in parte:\n            nome, link = parte.split(\"|\", 1)\n            nome = nome.strip()\n            link = link.strip()\n            if nome and link:\n                botoes.append((nome, link))\n            else:\n                erro = True\n        else:\n            erro = True\n    if erro or not botoes:\n        await update.message.reply_text(\n            \"Formato inv√°lido. Envie os bot√µes como: NOME|LINK, NOME2|LINK2\"\n        )\n        return RECEBER_BOTOES\n    context.user_data[\"botoes\"] = botoes\n    await mostrar_previa(update, context)\n    return CONFIRMAR_PREVIA\n\nasync def mostrar_previa(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    midia = context.user_data.get(\"midia\")\n    texto = context.user_data.get(\"texto\", \"\")\n    botoes = context.user_data.get(\"botoes\", [])\n    reply_markup = None\n    if botoes:\n        reply_markup = InlineKeyboardMarkup(\n            [[InlineKeyboardButton(nome, url=link)] for nome, link in botoes]\n        )\n    # Envia a pr√©via exatamente como ser√° publicada no grupo\n    if midia:\n        tipo, file_id = midia\n        if tipo == \"photo\":\n            await update.message.reply_photo(photo=file_id, caption=texto, reply_markup=reply_markup)\n        elif tipo == \"video\":\n            await update.message.reply_video(video=file_id, caption=texto, reply_markup=reply_markup)\n    else:\n        await update.message.reply_text(texto, reply_markup=reply_markup)\n    # Logo abaixo, exibe o menu de confirma√ß√£o/edi√ß√£o\n    keyboard = [\n        [InlineKeyboardButton(\"Confirmar\", callback_data=\"sim\")],\n        [InlineKeyboardButton(\"Editar\", callback_data=\"editar\")]\n    ]\n    reply_markup_confirm = InlineKeyboardMarkup(keyboard)\n    await update.message.reply_text(\"Est√° correto?\", reply_markup=reply_markup_confirm)\n\nasync def confirmar_previa_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    query = update.callback_query\n    await query.answer()\n    if query.data == \"sim\":\n        midia = context.user_data.get(\"midia\")\n        texto = context.user_data.get(\"texto\", \"\")\n        botoes = context.user_data.get(\"botoes\", [])\n        reply_markup = None\n        if botoes:\n            reply_markup = InlineKeyboardMarkup(\n                [[InlineKeyboardButton(nome, url=link)] for nome, link in botoes]\n            )\n        if midia:\n            tipo, file_id = midia\n            if tipo == \"photo\":\n                await context.bot.send_photo(chat_id=GROUP_CHAT_ID, photo=file_id, caption=texto, reply_markup=reply_markup)\n            elif tipo == \"video\":\n                await context.bot.send_video(chat_id=GROUP_CHAT_ID, video=file_id, caption=texto, reply_markup=reply_markup)\n        else:\n            await context.bot.send_message(chat_id=GROUP_CHAT_ID, text=texto, reply_markup=reply_markup)\n        await query.edit_message_text(\"Mensagem enviada ao grupo com sucesso!\")\n        return ConversationHandler.END\n    elif query.data == \"editar\":\n        keyboard = [\n            [InlineKeyboardButton(\"M√çDIA\", callback_data=\"editar_midia\")],\n            [InlineKeyboardButton(\"TEXTO\", callback_data=\"editar_texto\")],\n            [InlineKeyboardButton(\"BOT√ïES\", callback_data=\"editar_botoes\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        await query.edit_message_text(\"Qual parte deseja editar?\", reply_markup=reply_markup)\n        return EDITAR_ESCOLHA\n\nasync def editar_escolha_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    query = update.callback_query\n    await query.answer()\n    if query.data == \"editar_midia\":\n        await query.edit_message_text(\"Envie a nova m√≠dia (foto ou v√≠deo):\")\n        return RECEBER_MIDIA\n    elif query.data == \"editar_texto\":\n        await query.edit_message_text(\"Envie o novo texto:\")\n        return RECEBER_TEXTO\n    elif query.data == \"editar_botoes\":\n        await query.edit_message_text(\n            \"Envie os novos bot√µes no formato:\\nNOME|LINK, NOME2|LINK2\"\n        )\n        return RECEBER_BOTOES\n\nasync def mostrar_menu_encaminhamento(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    keyboard = [\n        [InlineKeyboardButton(\"Adicionar mais mensagens\", callback_data=\"add_msgs\")],\n        [InlineKeyboardButton(\"Finalizar\", callback_data=\"finalizar_encaminhamento\")],\n        [InlineKeyboardButton(\"Cancelar\", callback_data=\"cancelar_encaminhamento\")]\n    ]\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    # Envia ou atualiza o menu fixo\n    if context.user_data.get(\"menu_msg_id\"):\n        try:\n            await update.effective_chat.edit_message_reply_markup(\n                message_id=context.user_data[\"menu_msg_id\"],\n                reply_markup=reply_markup\n            )\n        except Exception:\n            pass\n    else:\n        msg = await update.effective_chat.send_message(\n            \"Quando terminar, clique em Finalizar.\\nPara cancelar, clique em Cancelar.\",\n            reply_markup=reply_markup\n        )\n        context.user_data[\"menu_msg_id\"] = msg.message_id\n\n# Utilit√°rio para atualizar o menu fixo\nasync def atualizar_menu_encaminhamento(context, chat_id, menu_msg_id, total):\n    keyboard = [\n        [InlineKeyboardButton(f\"Adicionar mais mensagens\", callback_data=\"add_msgs\")],\n        [InlineKeyboardButton(f\"Finalizar ({total} coletados)\", callback_data=\"finalizar_encaminhamento\")],\n        [InlineKeyboardButton(\"Cancelar\", callback_data=\"cancelar_encaminhamento\")]\n    ]\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    try:\n        await context.bot.edit_message_reply_markup(\n            chat_id=chat_id,\n            message_id=menu_msg_id,\n            reply_markup=reply_markup\n        )\n    except Exception:\n        pass\n\n# Handler para coletar mensagens encaminhadas:\nasync def receber_encaminhadas(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    msg = update.message\n    # Inicializa lista de itens e grupos\n    context.user_data.setdefault(\"forwarded_items\", [])\n    context.user_data.setdefault(\"media_groups\", {})\n    # Media group (√°lbum)\n    if msg.media_group_id:\n        group_id = msg.media_group_id\n        context.user_data[\"media_groups\"].setdefault(group_id, []).append(msg)\n        # Aguarda mais itens do grupo (Telegram envia em sequ√™ncia)\n        # S√≥ registra quando n√£o vier mais do mesmo grupo (tratado no menu)\n    else:\n        # Conte√∫do protegido\n        if getattr(msg, \"is_protected_content\", False):\n            await msg.reply_text(\"Conte√∫do protegido contra c√≥pia. Encaminhe outro item.\")\n            return FORWARD_COLLECT\n        context.user_data[\"forwarded_items\"].append(msg)\n    # Atualiza menu fixo\n    total = len(context.user_data[\"forwarded_items\"]) + sum(len(g) for g in context.user_data[\"media_groups\"].values())\n    if not context.user_data.get(\"menu_msg_id\"):\n        menu = await msg.reply_text(\n            f\"Encaminhe mensagens. Quando terminar, clique em Finalizar.\\nItens coletados: {total}\",\n            reply_markup=InlineKeyboardMarkup([\n                [InlineKeyboardButton(\"Adicionar mais mensagens\", callback_data=\"add_msgs\")],\n                [InlineKeyboardButton(f\"Finalizar ({total} coletados)\", callback_data=\"finalizar_encaminhamento\")],\n                [InlineKeyboardButton(\"Cancelar\", callback_data=\"cancelar_encaminhamento\")]\n            ])\n        )\n        context.user_data[\"menu_msg_id\"] = menu.message_id\n    else:\n        await atualizar_menu_encaminhamento(context, msg.chat_id, context.user_data[\"menu_msg_id\"], total)\n    return FORWARD_COLLECT\n\nasync def comando_pronto(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    if not context.user_data.get(\"encaminhadas\"):\n        await update.message.reply_text(\"Voc√™ n√£o encaminhou nenhuma mensagem. Encaminhe ao menos uma antes de digitar /pronto.\")\n        return RECEBER_ENCAMINHADAS\n    await update.message.reply_text(\"Agora envie o link de destino (grupo, canal ou chat):\")\n    return RECEBER_LINK  # <-- AVAN√áA PARA O PR√ìXIMO ESTADO\n\n# Handler para coletar o link de destino:\nasync def receber_link(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    link = update.message.text.strip()\n    # Valida√ß√£o simples: t.me/username ou chat_id\n    if link.startswith(\"t.me/\"):\n        await update.message.reply_text(\"Por favor, pe√ßa para o destino enviar uma mensagem para o bot ou informe o @username ou chat_id.\")\n        return RECEBER_LINK\n    context.user_data[\"destino\"] = link\n    await mostrar_previa_repassar(update, context)\n    return CONFIRMAR_REPASSAR\n\n# Fun√ß√£o para mostrar a pr√©via das mensagens encaminhadas:\nasync def mostrar_previa_repassar(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    items = context.user_data.get(\"forwarded_items\", [])\n    destino = context.user_data.get(\"destino\", \"\")\n    preview = f\"Pr√©via do repasse para: {destino}\\n\\n\"\n    for idx, item in enumerate(items, 1):\n        if isinstance(item, list):  # Media group\n            preview += f\"{idx}. [√Ålbum com {len(item)} m√≠dias]\\n\"\n            for m in item:\n                if m.photo:\n                    preview += \"   - Foto\\n\"\n                elif m.video:\n                    preview += \"   - V√≠deo\\n\"\n                elif m.document:\n                    preview += \"   - Documento\\n\"\n                elif m.audio:\n                    preview += \"   - √Åudio\\n\"\n                elif m.voice:\n                    preview += \"   - Voz\\n\"\n                elif m.sticker:\n                    preview += \"   - Sticker\\n\"\n                if m.caption:\n                    preview += f\"     Legenda: {m.caption}\\n\"\n        else:\n            if item.text:\n                preview += f\"{idx}. Texto: {item.text}\\n\"\n            elif item.photo:\n                preview += f\"{idx}. Foto\\n\"\n                if item.caption:\n                    preview += f\"   Legenda: {item.caption}\\n\"\n            elif item.video:\n                preview += f\"{idx}. V√≠deo\\n\"\n                if item.caption:\n                    preview += f\"   Legenda: {item.caption}\\n\"\n            elif item.document:\n                preview += f\"{idx}. Documento\\n\"\n                if item.caption:\n                    preview += f\"   Legenda: {item.caption}\\n\"\n            elif item.audio:\n                preview += f\"{idx}. √Åudio\\n\"\n                if item.caption:\n                    preview += f\"   Legenda: {item.caption}\\n\"\n            elif item.voice:\n                preview += f\"{idx}. Voz\\n\"\n            elif item.sticker:\n                preview += f\"{idx}. Sticker\\n\"\n    await update.message.reply_text(preview)\n    keyboard = [\n        [InlineKeyboardButton(\"Confirmar\", callback_data=\"confirmar_repassar\")],\n        [InlineKeyboardButton(\"Editar\", callback_data=\"editar_repassar\")]\n    ]\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    await update.message.reply_text(\"Est√° correto?\", reply_markup=reply_markup)\n\n# Handler para confirma√ß√£o ou edi√ß√£o:\nasync def confirmar_repassar_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    query = update.callback_query\n    await query.answer()\n\n    if query.data == \"confirmar_repassar\":\n        destino = context.user_data.get(\"destino\")\n        items = context.user_data.get(\"forwarded_items\", [])\n\n        if not destino:\n            await query.message.reply_text(\"Destino n√£o definido. Envie novamente o link ou chat_id.\")\n            return RECEBER_LINK\n\n        enviados = 0  # Contador de itens enviados\n\n        for item in items:\n            if isinstance(item, list):  # Media group\n                media_objs = []\n                for m in item:\n                    if getattr(m, \"is_protected_content\", False):\n                        continue  # Ignora m√≠dias protegidas\n                    if m.photo:\n                        media_objs.append(InputMediaPhoto(media=m.photo[-1].file_id, caption=m.caption or \"\"))\n                    elif m.video:\n                        media_objs.append(InputMediaVideo(media=m.video.file_id, caption=m.caption or \"\"))\n                    elif m.document:\n                        media_objs.append(InputMediaDocument(media=m.document.file_id, caption=m.caption or \"\"))\n                if media_objs:\n                    try:\n                        await query.bot.send_media_group(chat_id=destino, media=media_objs)\n                        enviados += len(media_objs)\n                    except Exception:\n                        await query.message.reply_text(\n                            \"N√£o foi poss√≠vel enviar um dos √°lbuns. Verifique se o destino √© v√°lido.\"\n                        )\n            else:\n                if getattr(item, \"is_protected_content\", False):\n                    continue  # Ignora itens protegidos\n                try:\n                    await item.copy_to(chat_id=destino)\n                    enviados += 1\n                except Exception:\n                    await query.message.reply_text(\n                        \"N√£o foi poss√≠vel copiar um dos itens. Verifique se o destino √© v√°lido.\"\n                    )\n\n        if enviados > 0:\n            await query.edit_message_text(f\"Mensagens repassadas com sucesso! ({enviados} itens enviados)\")\n        else:\n            await query.edit_message_text(\"Nenhum item p√¥de ser repassado. Todos eram protegidos ou o destino √© inv√°lido.\")\n\n        return ConversationHandler.END\n\n    elif query.data == \"editar_repassar\":\n        keyboard = [\n            [InlineKeyboardButton(\"Alterar link de destino\", callback_data=\"editar_link\")],\n            [InlineKeyboardButton(\"Remover todos os itens\", callback_data=\"editar_msgs\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        await query.edit_message_text(\"O que deseja editar?\", reply_markup=reply_markup)\n        return EDITAR_REPASSAR\n\n\n# Handler para edi√ß√£o:\nasync def editar_repassar_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    query = update.callback_query\n    await query.answer()\n    if query.data == \"editar_link\":\n        await query.edit_message_text(\"Envie o novo link de destino:\")\n        return RECEBER_LINK\n    elif query.data == \"editar_msgs\":\n        context.user_data[\"forwarded_items\"] = []\n        await query.edit_message_text(\"Encaminhe novamente as mensagens para este chat. Clique em Finalizar quando terminar.\")\n        return FORWARD_COLLECT\n\nasync def confirmar_conexao(app):\n    bot_info = await app.bot.get_me()\n    print(f\"Bot [{bot_info.first_name}] conectado com sucesso e online.\")\n\nasync def menu_encaminhamento_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    query = update.callback_query\n    await query.answer()\n    total = len(context.user_data.get(\"forwarded_items\", [])) + sum(len(g) for g in context.user_data.get(\"media_groups\", {}).values())\n    if query.data == \"add_msgs\":\n        await query.edit_message_reply_markup(reply_markup=query.message.reply_markup)\n        await query.message.reply_text(\"Continue encaminhando mensagens para este chat.\")\n        return FORWARD_COLLECT\n    elif query.data == \"finalizar_encaminhamento\":\n        # Finaliza media groups (adiciona todos como conjuntos)\n        for group in context.user_data.get(\"media_groups\", {}).values():\n            context.user_data[\"forwarded_items\"].append(group)\n        context.user_data[\"media_groups\"] = {}\n        if not context.user_data.get(\"forwarded_items\"):\n            await query.message.reply_text(\"Voc√™ n√£o encaminhou nenhuma mensagem. Encaminhe ao menos uma antes de finalizar.\")\n            return FORWARD_COLLECT\n        # Remove menu fixo\n        try:\n            await query.message.edit_reply_markup(reply_markup=None)\n        except Exception:\n            pass\n        context.user_data[\"menu_msg_id\"] = None\n        await query.message.reply_text(\"Agora envie o link de destino (grupo, canal ou chat):\")\n        return RECEBER_LINK\n    elif query.data == \"cancelar_encaminhamento\":\n        try:\n            await query.message.edit_reply_markup(reply_markup=None)\n        except Exception:\n            pass\n        context.user_data[\"menu_msg_id\"] = None\n        context.user_data[\"forwarded_items\"] = []\n        context.user_data[\"media_groups\"] = {}\n        await query.message.reply_text(\"Processo cancelado. Voltando ao menu principal.\")\n        return ConversationHandler.END\n\ndef main() -> None:\n    token = input(\"Digite o token do bot do Telegram: \").strip()\n    app = ApplicationBuilder().token(token).post_init(confirmar_conexao).build()\n    conv_handler = ConversationHandler(\n    entry_points=[CallbackQueryHandler(button_handler, pattern=\"^opcao4$|^opcao5$\")],\n    states={\n        # Menu de envio de m√≠dia/texto/bot√µes\n        MENU_ENVIO: [\n            CallbackQueryHandler(menu_envio_handler, pattern=\"^(midia|texto|botoes|iniciar)$\")\n        ],\n        RECEBER_MIDIA: [\n            MessageHandler(filters.PHOTO | filters.VIDEO, receber_midia)\n        ],\n        RECEBER_TEXTO: [\n            MessageHandler(filters.TEXT & ~filters.COMMAND, receber_texto)\n        ],\n        RECEBER_BOTOES: [\n            MessageHandler(filters.TEXT & ~filters.COMMAND, receber_botoes)\n        ],\n        CONFIRMAR_PREVIA: [\n            CallbackQueryHandler(confirmar_previa_handler, pattern=\"^(sim|editar)$\")\n        ],\n        EDITAR_ESCOLHA: [\n            CallbackQueryHandler(editar_escolha_handler, pattern=\"^editar_(midia|texto|botoes)$\")\n        ],\n\n        # Menu de encaminhamento de mensagens\n        RECEBER_ENCAMINHADAS: [\n            MessageHandler(filters.FORWARDED & ~filters.COMMAND, receber_encaminhadas)\n        ],\n        FORWARD_COLLECT: [\n            MessageHandler(filters.FORWARDED & ~filters.COMMAND, receber_encaminhadas),\n            CallbackQueryHandler(menu_encaminhamento_handler,\n                                 pattern=\"^(add_msgs|finalizar_encaminhamento|cancelar_encaminhamento)$\")\n        ],\n        RECEBER_LINK: [\n            MessageHandler(filters.TEXT & ~filters.COMMAND, receber_link)\n        ],\n        CONFIRMAR_REPASSAR: [\n            CallbackQueryHandler(confirmar_repassar_handler, pattern=\"^(confirmar_repassar|editar_repassar)$\")\n        ],\n        EDITAR_REPASSAR: [\n            CallbackQueryHandler(editar_repassar_handler, pattern=\"^(editar_link|editar_msgs)$\")\n        ]\n    },\n    fallbacks=[]\n)\n\n    app.add_handler(CallbackQueryHandler(button_handler, pattern=\"^(opcao1|opcao2|opcao3)$\"))\n    app.add_handler(conv_handler)\n    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, start))\n    app.run_polling()\n\nif __name__ == '__main__':\n    main()","size_bytes":23017},"handlers/callback_handlers.py":{"content":"from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import ContextTypes, ConversationHandler\nfrom config import GROUP_CHAT_ID, MENU_ENVIO, RECEBER_MIDIA, RECEBER_TEXTO, RECEBER_BOTOES, EDITAR_ESCOLHA, RECEBER_ENCAMINHADAS, FORWARD_COLLECT, RECEBER_LINK, CONFIRMAR_REPASSAR, SELECIONAR_GRUPO, CONFIRMAR_GRUPO, MENU_EDICAO, ADICIONAR_TEXTO, ADICIONAR_BOTAO_TITULO, ADICIONAR_BOTAO_LINK, REMOVER_PALAVRA, CONFIRMAR_EDICAO\nfrom utils.storage import get_destination_group, set_destination_group, get_destination_groups, add_destination_group, remove_destination_group\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nasync def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Handle main menu button clicks.\"\"\"\n    query = update.callback_query\n    \n    # Always answer callback, ignore if expired\n    try:\n        await query.answer()\n    except Exception:\n        # Ignore expired callbacks, continue processing\n        pass\n    \n    try:\n        if query.data == \"opcao1\":\n            from handlers.message_handlers import mostrar_menu_gerenciar_grupos\n            return await mostrar_menu_gerenciar_grupos(update, context)\n        elif query.data == \"opcao2\":\n            await query.edit_message_text(\"Voc√™ selecionou: Lista de cursos\")\n            return ConversationHandler.END\n        elif query.data == \"opcao3\":\n            await query.edit_message_text(\"Voc√™ selecionou: Grupo VIP\")\n            return ConversationHandler.END\n        elif query.data == \"opcao4\":\n            # Check if there are groups registered\n            grupos = context.user_data.get(\"grupos\", [])\n            if not grupos:\n                keyboard = [[InlineKeyboardButton(\"üè† Voltar ao Menu Principal\", callback_data=\"voltar_menu\")]]\n                reply_markup = InlineKeyboardMarkup(keyboard)\n                await query.edit_message_text(\n                    \"‚ùå Nenhum grupo cadastrado.\\n\\n\"\n                    \"Use a op√ß√£o 'Gerenciar grupos' primeiro.\",\n                    reply_markup=reply_markup\n                )\n                return ConversationHandler.END\n            \n            # Show destination selection first\n            from handlers.message_handlers import mostrar_selecao_destinos\n            return await mostrar_selecao_destinos(update, context, \"envio\")\n        elif query.data == \"opcao5\":\n            # Check if there are groups registered\n            grupos = context.user_data.get(\"grupos\", [])\n            if not grupos:\n                keyboard = [[InlineKeyboardButton(\"üè† Voltar ao Menu Principal\", callback_data=\"voltar_menu\")]]\n                reply_markup = InlineKeyboardMarkup(keyboard)\n                \n                await query.edit_message_text(\n                    \"‚ùå Nenhum grupo cadastrado.\\n\\n\"\n                    \"Use a op√ß√£o 'Gerenciar grupos' primeiro.\",\n                    reply_markup=reply_markup\n                )\n                return ConversationHandler.END\n            \n            # Show destination selection first\n            from handlers.message_handlers import mostrar_selecao_destinos\n            return await mostrar_selecao_destinos(update, context, \"repassar\")\n    except Exception as e:\n        logger.error(f\"Error in button_handler: {e}\")\n        await query.edit_message_text(\"Erro ao processar sele√ß√£o. Tente novamente.\")\n    \n    return ConversationHandler.END\n\nasync def menu_envio_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Handle message creation menu selections.\"\"\"\n    query = update.callback_query\n    \n    # Always answer callback, ignore if expired\n    try:\n        await query.answer()\n    except Exception:\n        # Ignore expired callbacks, continue processing\n        pass\n    \n    # Always answer callback immediately\n    try:\n        await query.answer()\n    except Exception as e:\n        logger.warning(f\"Failed to answer callback: {e}\")\n        try:\n            await query.message.reply_text(\"‚ö†Ô∏è Essa a√ß√£o expirou. Abra o menu novamente enviando qualquer mensagem.\")\n            return ConversationHandler.END\n        except Exception:\n            return ConversationHandler.END\n    \n    try:\n        if query.data == \"midia\":\n            await query.edit_message_text(\"Voc√™ selecionou: M√çDIA.\")\n            return MENU_ENVIO\n        elif query.data == \"texto\":\n            await query.edit_message_text(\"Voc√™ selecionou: TEXTO.\")\n            return MENU_ENVIO\n        elif query.data == \"botoes\":\n            await query.edit_message_text(\"Voc√™ selecionou: BOT√ïES.\")\n            return MENU_ENVIO\n        elif query.data == \"iniciar\":\n            await query.edit_message_text(\"Envie a m√≠dia (foto ou v√≠deo) que deseja postar:\")\n            return RECEBER_MIDIA\n    except Exception as e:\n        logger.error(f\"Error in menu_envio_handler: {e}\")\n        await query.edit_message_text(\"Erro ao processar sele√ß√£o. Tente novamente.\")\n    \n    return MENU_ENVIO\n\nasync def confirmar_previa_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Handle preview confirmation.\"\"\"\n    query = update.callback_query\n    \n    # Always answer callback, ignore if expired\n    try:\n        await query.answer()\n    except Exception:\n        # Ignore expired callbacks, continue processing\n        pass\n    \n    try:\n        if query.data == \"sim\":\n            # Send message to selected destination group\n            selected_destination = context.user_data.get(\"selected_destination\")\n            if not selected_destination:\n                await query.edit_message_text(\"‚ùå Erro: nenhum destino selecionado.\")\n                return ConversationHandler.END\n            \n            midia = context.user_data.get(\"midia\")\n            texto = context.user_data.get(\"texto\", \"\")\n            botoes = context.user_data.get(\"botoes\", [])\n            \n            reply_markup = None\n            if botoes:\n                reply_markup = InlineKeyboardMarkup(\n                    [[InlineKeyboardButton(nome, url=link)] for nome, link in botoes]\n                )\n            \n            destination_chat_id = selected_destination[\"chat_id\"]\n            \n            if midia:\n                tipo, file_id = midia\n                if tipo == \"photo\":\n                    await context.bot.send_photo(\n                        chat_id=destination_chat_id,\n                        photo=file_id,\n                        caption=texto,\n                        reply_markup=reply_markup\n                    )\n                elif tipo == \"video\":\n                    await context.bot.send_video(\n                        chat_id=destination_chat_id,\n                        video=file_id,\n                        caption=texto,\n                        reply_markup=reply_markup\n                    )\n            else:\n                await context.bot.send_message(\n                    chat_id=destination_chat_id,\n                    text=texto,\n                    reply_markup=reply_markup\n                )\n            \n            # Show success message with return to menu option\n            keyboard = [[InlineKeyboardButton(\"üè† Voltar ao Menu Principal\", callback_data=\"voltar_menu\")]]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await query.edit_message_text(\n                f\"‚úÖ Mensagem enviada para {selected_destination['name']} com sucesso!\",\n                reply_markup=reply_markup\n            )\n            return ConversationHandler.END\n            \n        elif query.data == \"editar\":\n            keyboard = [\n                [InlineKeyboardButton(\"M√çDIA\", callback_data=\"editar_midia\")],\n                [InlineKeyboardButton(\"TEXTO\", callback_data=\"editar_texto\")],\n                [InlineKeyboardButton(\"BOT√ïES\", callback_data=\"editar_botoes\")]\n            ]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            await query.edit_message_text(\"Qual parte deseja editar?\", reply_markup=reply_markup)\n            return EDITAR_ESCOLHA\n    except Exception as e:\n        logger.error(f\"Error in confirmar_previa_handler: {e}\")\n        await query.edit_message_text(\"Erro ao processar confirma√ß√£o. Tente novamente.\")\n    \n    return ConversationHandler.END\n\nasync def editar_escolha_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Handle edit choice selection.\"\"\"\n    query = update.callback_query\n    \n    # Always answer callback immediately\n    try:\n        await query.answer()\n    except Exception as e:\n        logger.warning(f\"Failed to answer callback: {e}\")\n        try:\n            await query.message.reply_text(\"‚ö†Ô∏è Essa a√ß√£o expirou. Abra o menu novamente enviando qualquer mensagem.\")\n            return ConversationHandler.END\n        except Exception:\n            return ConversationHandler.END\n    \n    try:\n        if query.data == \"editar_midia\":\n            await query.edit_message_text(\"Envie a nova m√≠dia (foto ou v√≠deo):\")\n            return RECEBER_MIDIA\n        elif query.data == \"editar_texto\":\n            await query.edit_message_text(\"Envie o novo texto:\")\n            return RECEBER_TEXTO\n        elif query.data == \"editar_botoes\":\n            await query.edit_message_text(\n                \"Envie os novos bot√µes no formato:\\nNOME|LINK, NOME2|LINK2\"\n            )\n            return RECEBER_BOTOES\n    except Exception as e:\n        logger.error(f\"Error in editar_escolha_handler: {e}\")\n        await query.edit_message_text(\"Erro ao processar edi√ß√£o. Tente novamente.\")\n    \n    return EDITAR_ESCOLHA\n\nasync def encaminhamento_callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Handle forwarding menu callbacks.\"\"\"\n    query = update.callback_query\n    await query.answer()\n    \n    try:\n        if query.data == \"finalizar_coleta\":\n            # User wants to finish collecting and start editing\n            user_id = update.effective_user.id\n            messages = context.bot_data.get('mensagens_temp', {}).get(user_id, [])\n            \n            if not messages:\n                await query.edit_message_text(\"‚ùå Nenhuma mensagem encontrada.\")\n                return ConversationHandler.END\n            \n            # Initialize editing data for all messages\n            context.user_data[\"messages_to_edit\"] = messages\n            context.user_data[\"edited_data\"] = []\n            context.user_data[\"added_buttons\"] = []\n            \n            # Extract text/caption with entities from each message\n            for msg_data in messages:\n                edited_item = {\n                    'text': msg_data['text'],\n                    'caption': msg_data['caption'],\n                    'entities': msg_data['entities'][:] if msg_data['entities'] else [],\n                    'caption_entities': msg_data['caption_entities'][:] if msg_data['caption_entities'] else [],\n                    'file_id': msg_data['file_id'],\n                    'media_type': msg_data['media_type']\n                }\n                context.user_data[\"edited_data\"].append(edited_item)\n            \n            # Show bulk editing menu\n            keyboard = [\n                [InlineKeyboardButton(\"‚úèÔ∏è Adicionar texto a todas\", callback_data=\"adicionar_texto_bulk\")],\n                [InlineKeyboardButton(\"üîó Adicionar bot√£o a todas\", callback_data=\"adicionar_botao_bulk\")],\n                [InlineKeyboardButton(\"üóëÔ∏è Remover palavra de todas\", callback_data=\"remover_palavra_bulk\")],\n                [InlineKeyboardButton(\"üëÅÔ∏è Ver pr√©via de todas\", callback_data=\"previa_bulk\")],\n                [InlineKeyboardButton(\"üì§ Enviar todas sem editar\", callback_data=\"enviar_bulk\")]\n            ]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            total = len(messages)\n            await query.edit_message_text(\n                f\"üìù **Menu de Edi√ß√£o em Lote**\\n\\n\"\n                f\"Total de mensagens: {total}\\n\\n\"\n                \"Escolha como deseja editar todas as mensagens:\",\n                reply_markup=reply_markup,\n                parse_mode=\"Markdown\"\n            )\n            \n            return MENU_EDICAO\n            \n        elif query.data == \"continuar_coleta\":\n            # User wants to continue collecting messages\n            await query.edit_message_text(\"üì• Continue enviando mensagens...\")\n            return FORWARD_COLLECT\n            \n        elif query.data == \"add_msgs\":\n            await query.edit_message_text(\"Continue encaminhando mensagens...\")\n            return FORWARD_COLLECT\n            \n        elif query.data == \"finalizar_encaminhamento\":\n            total_sent = context.user_data.get(\"messages_sent\", 0)\n            \n            keyboard = [[InlineKeyboardButton(\"üè† Voltar ao Menu Principal\", callback_data=\"voltar_menu\")]]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            if total_sent == 0:\n                await query.edit_message_text(\n                    \"Nenhuma mensagem foi enviada. Opera√ß√£o finalizada.\",\n                    reply_markup=reply_markup\n                )\n            else:\n                await query.edit_message_text(\n                    f\"‚úÖ Processo finalizado!\\n\\n\"\n                    f\"Total de mensagens enviadas: {total_sent}\",\n                    reply_markup=reply_markup\n                )\n            \n            return ConversationHandler.END\n            \n        elif query.data == \"cancelar_encaminhamento\":\n            keyboard = [[InlineKeyboardButton(\"üè† Voltar ao Menu Principal\", callback_data=\"voltar_menu\")]]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await query.edit_message_text(\n                \"Opera√ß√£o cancelada.\",\n                reply_markup=reply_markup\n            )\n            return ConversationHandler.END\n            \n        elif query.data == \"confirmar_repassar\":\n            await executar_repassar(update, context)\n            return ConversationHandler.END\n            \n        elif query.data == \"cancelar_repassar\":\n            await query.edit_message_text(\"Reenvio cancelado.\")\n            return ConversationHandler.END\n            \n        # Group registration callbacks\n        elif query.data == \"confirmar_grupo\":\n            try:\n                group_id = context.user_data.get(\"pending_group_id\")\n                if group_id and set_destination_group(group_id):\n                    keyboard = [[InlineKeyboardButton(\"üè† Voltar ao Menu Principal\", callback_data=\"voltar_menu\")]]\n                    reply_markup = InlineKeyboardMarkup(keyboard)\n                    \n                    await query.edit_message_text(\n                        f\"‚úÖ Grupo cadastrado com sucesso!\\n\\n\"\n                        f\"ID: {group_id}\\n\\n\"\n                        f\"Agora voc√™ pode usar a op√ß√£o 'Repassar mensagens' para enviar conte√∫do automaticamente para este grupo.\",\n                        reply_markup=reply_markup\n                    )\n                else:\n                    await query.edit_message_text(\"‚ùå Erro ao salvar grupo. Tente novamente.\")\n                return ConversationHandler.END\n            except Exception as e:\n                logger.error(f\"Error confirming group: {e}\")\n                await query.edit_message_text(\"Erro ao confirmar grupo.\")\n                return ConversationHandler.END\n                \n        elif query.data == \"alterar_grupo\":\n            await query.edit_message_text(\n                \"Envie o ID ou nome de outro grupo:\\n\\n\"\n                \"Formato: -100xxxxxxxxx (para supergrupos) ou @nomecanal (para canais p√∫blicos)\"\n            )\n            return SELECIONAR_GRUPO\n            \n        elif query.data == \"cancelar_grupo\":\n            await query.edit_message_text(\"Cadastro de grupo cancelado.\")\n            return ConversationHandler.END\n            \n        elif query.data == \"voltar_menu\":\n            # Clear any conversation state and return to main menu\n            context.user_data.clear()\n            from handlers.message_handlers import start\n            await start(update, context)\n            return ConversationHandler.END\n        \n        # Group management callbacks\n        elif query.data == \"cadastrar_grupo\":\n            from handlers.message_handlers import cadastrar_novo_grupo\n            return await cadastrar_novo_grupo(update, context)\n        \n        elif query.data == \"ver_grupos\":\n            from handlers.message_handlers import mostrar_grupos_cadastrados\n            return await mostrar_grupos_cadastrados(update, context)\n        \n        elif query.data == \"gerenciar_grupos\":\n            from handlers.message_handlers import mostrar_menu_gerenciar_grupos\n            return await mostrar_menu_gerenciar_grupos(update, context)\n        \n        elif query.data.startswith(\"confirmar_cadastro_\"):\n            chat_id = query.data.replace(\"confirmar_cadastro_\", \"\")\n            pending_group = context.user_data.get(\"pending_group\", {})\n            \n            if pending_group:\n                # Add group to user's list\n                if \"grupos\" not in context.user_data:\n                    context.user_data[\"grupos\"] = []\n                \n                context.user_data[\"grupos\"].append({\n                    \"name\": pending_group[\"name\"],\n                    \"chat_id\": pending_group[\"chat_id\"],\n                    \"input\": pending_group[\"input\"]\n                })\n                \n                keyboard = [[InlineKeyboardButton(\"üè† Voltar ao Menu Principal\", callback_data=\"voltar_menu\")]]\n                reply_markup = InlineKeyboardMarkup(keyboard)\n                \n                await query.edit_message_text(\n                    f\"‚úÖ **Grupo cadastrado com sucesso!**\\n\\n\"\n                    f\"**Nome:** {pending_group['name']}\\n\"\n                    f\"**ID:** {pending_group['chat_id']}\\n\\n\"\n                    \"Agora voc√™ pode usar as op√ß√µes de envio de mensagem!\",\n                    reply_markup=reply_markup,\n                    parse_mode=\"Markdown\"\n                )\n                \n                # Clear pending data\n                context.user_data.pop(\"pending_group\", None)\n                return ConversationHandler.END\n            else:\n                await query.edit_message_text(\"‚ùå Erro: dados do grupo n√£o encontrados.\")\n                return ConversationHandler.END\n        \n        elif query.data.startswith(\"remover_grupo_\"):\n            group_index = int(query.data.replace(\"remover_grupo_\", \"\"))\n            grupos = context.user_data.get(\"grupos\", [])\n            \n            if 0 <= group_index < len(grupos):\n                removed_group = grupos.pop(group_index)\n                \n                keyboard = [\n                    [InlineKeyboardButton(\"üîô Voltar aos grupos\", callback_data=\"ver_grupos\")],\n                    [InlineKeyboardButton(\"üè† Menu Principal\", callback_data=\"voltar_menu\")]\n                ]\n                reply_markup = InlineKeyboardMarkup(keyboard)\n                \n                await query.edit_message_text(\n                    f\"üóëÔ∏è **Grupo removido**\\n\\n\"\n                    f\"O grupo '{removed_group['name']}' foi removido da lista.\",\n                    reply_markup=reply_markup,\n                    parse_mode=\"Markdown\"\n                )\n            else:\n                await query.edit_message_text(\"‚ùå Erro ao remover grupo.\")\n            return SELECIONAR_GRUPO\n        \n        elif query.data.startswith(\"destino_\"):\n            # Handle destination selection for sending messages\n            parts = query.data.split(\"_\")\n            if len(parts) >= 3:\n                action_type = parts[1]  # \"envio\" or \"repassar\"\n                group_index = int(parts[2])\n                \n                grupos = context.user_data.get(\"grupos\", [])\n                if 0 <= group_index < len(grupos):\n                    selected_group = grupos[group_index]\n                    context.user_data[\"selected_destination\"] = selected_group\n                    \n                    if action_type == \"envio\":\n                        # Start message creation flow\n                        await query.edit_message_text(\"Envie a m√≠dia (foto ou v√≠deo) que deseja postar:\")\n                        return RECEBER_MIDIA\n                    elif action_type == \"repassar\":\n                        # Start message forwarding flow\n                        await query.edit_message_text(\n                            f\"üéØ **Destino selecionado:** {selected_group['name']}\\n\\n\"\n                            \"üì• **Agora envie as mensagens** que deseja repassar:\\n\\n\"\n                            \"‚Ä¢ Envie quantas mensagens quiser\\n\"\n                            \"‚Ä¢ Quando terminar, clique em 'Finalizar e editar'\"\n                        )\n                        \n                        # Initialize message collection\n                        user_id = update.effective_user.id\n                        if 'mensagens_temp' not in context.bot_data:\n                            context.bot_data['mensagens_temp'] = {}\n                        context.bot_data['mensagens_temp'][user_id] = []\n                        \n                        return RECEBER_ENCAMINHADAS\n                else:\n                    await query.edit_message_text(\"‚ùå Grupo selecionado inv√°lido.\")\n                    return ConversationHandler.END\n            \n        elif query.data == \"cancelar_cadastro\":\n            context.user_data.pop(\"pending_group\", None)\n            from handlers.message_handlers import mostrar_menu_gerenciar_grupos\n            return await mostrar_menu_gerenciar_grupos(update, context)\n            \n    except Exception as e:\n        logger.error(f\"Error in encaminhamento_callback_handler: {e}\")\n        await query.edit_message_text(\"Erro ao processar sele√ß√£o. Tente novamente.\")\n    \n    return FORWARD_COLLECT\n\nasync def mostrar_menu_encaminhamento(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Show forwarding menu.\"\"\"\n    keyboard = [\n        [InlineKeyboardButton(\"Adicionar mais mensagens\", callback_data=\"add_msgs\")],\n        [InlineKeyboardButton(\"Finalizar\", callback_data=\"finalizar_encaminhamento\")],\n        [InlineKeyboardButton(\"Cancelar\", callback_data=\"cancelar_encaminhamento\")]\n    ]\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    \n    try:\n        if context.user_data.get(\"menu_msg_id\"):\n            await update.effective_chat.edit_message_reply_markup(\n                message_id=context.user_data[\"menu_msg_id\"],\n                reply_markup=reply_markup\n            )\n        else:\n            msg = await update.effective_chat.send_message(\n                \"Quando terminar, clique em Finalizar.\\nPara cancelar, clique em Cancelar.\",\n                reply_markup=reply_markup\n            )\n            context.user_data[\"menu_msg_id\"] = msg.message_id\n    except Exception as e:\n        logger.error(f\"Error showing forwarding menu: {e}\")\n\nasync def executar_repassar(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Execute the forwarding of collected messages.\"\"\"\n    try:\n        link_destino = context.user_data.get(\"link_destino\")\n        forwarded_items = context.user_data.get(\"forwarded_items\", [])\n        media_groups = context.user_data.get(\"media_groups\", {})\n        \n        # Convert link to chat_id if it's a username\n        chat_id = link_destino\n        if link_destino.startswith(\"t.me/\"):\n            chat_id = f\"@{link_destino.split('/')[-1]}\"\n        elif link_destino.startswith(\"@\"):\n            chat_id = link_destino\n        else:\n            try:\n                chat_id = int(link_destino)\n            except ValueError:\n                await update.callback_query.edit_message_text(\"Formato de link inv√°lido.\")\n                return\n        \n        total_sent = 0\n        \n        # Copy individual messages\n        for msg in forwarded_items:\n            try:\n                await context.bot.copy_message(\n                    chat_id=chat_id,\n                    from_chat_id=msg.chat_id,\n                    message_id=msg.message_id\n                )\n                total_sent += 1\n            except Exception as e:\n                logger.error(f\"Error forwarding message {msg.message_id}: {e}\")\n        \n        # Copy media groups\n        for group_messages in media_groups.values():\n            for msg in group_messages:\n                try:\n                    await context.bot.copy_message(\n                        chat_id=chat_id,\n                        from_chat_id=msg.chat_id,\n                        message_id=msg.message_id\n                    )\n                    total_sent += 1\n                except Exception as e:\n                    logger.error(f\"Error forwarding media group message {msg.message_id}: {e}\")\n        \n        keyboard = [[InlineKeyboardButton(\"üè† Voltar ao Menu Principal\", callback_data=\"voltar_menu\")]]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.callback_query.edit_message_text(\n            f\"‚úÖ Sucesso! {total_sent} mensagens foram repassadas para {link_destino}\",\n            reply_markup=reply_markup\n        )\n        \n    except Exception as e:\n        logger.error(f\"Error in executar_repassar: {e}\")\n        await update.callback_query.edit_message_text(\n            \"Erro ao repassar mensagens. Verifique se o destino √© v√°lido e tente novamente.\"\n        )\n\nasync def menu_edicao_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Handle bulk editing menu callbacks.\"\"\"\n    query = update.callback_query\n    await query.answer()\n    \n    try:\n        if query.data == \"adicionar_texto_bulk\":\n            await query.edit_message_text(\"‚úèÔ∏è Digite o texto que deseja adicionar ao final de todas as mensagens:\")\n            return ADICIONAR_TEXTO\n            \n        elif query.data == \"adicionar_botao_bulk\":\n            await query.edit_message_text(\"üîó Digite o t√≠tulo do bot√£o que ser√° adicionado a todas as mensagens:\")\n            return ADICIONAR_BOTAO_TITULO\n            \n        elif query.data == \"remover_palavra_bulk\":\n            await query.edit_message_text(\"üóëÔ∏è Digite a palavra que deseja remover de todas as mensagens:\")\n            return REMOVER_PALAVRA\n            \n        elif query.data == \"previa_bulk\":\n            return await mostrar_previa_completa_bulk(update, context)\n            \n        elif query.data == \"enviar_bulk\":\n            return await enviar_mensagens_bulk(update, context)\n            \n        elif query.data == \"confirmar_envio_bulk\":\n            return await enviar_mensagens_bulk(update, context)\n            \n        elif query.data == \"voltar_edicao\":\n            # Show bulk editing menu again\n            messages = context.user_data.get(\"messages_to_edit\", [])\n            keyboard = [\n                [InlineKeyboardButton(\"‚úèÔ∏è Adicionar texto a todas\", callback_data=\"adicionar_texto_bulk\")],\n                [InlineKeyboardButton(\"üîó Adicionar bot√£o a todas\", callback_data=\"adicionar_botao_bulk\")],\n                [InlineKeyboardButton(\"üóëÔ∏è Remover palavra de todas\", callback_data=\"remover_palavra_bulk\")],\n                [InlineKeyboardButton(\"üëÅÔ∏è Ver pr√©via de todas\", callback_data=\"previa_bulk\")],\n                [InlineKeyboardButton(\"üì§ Enviar todas sem editar\", callback_data=\"enviar_bulk\")]\n            ]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            total = len(messages)\n            await query.edit_message_text(\n                f\"üìù **Menu de Edi√ß√£o em Lote**\\n\\n\"\n                f\"Total de mensagens: {total}\\n\\n\"\n                \"Escolha como deseja editar todas as mensagens:\",\n                reply_markup=reply_markup,\n                parse_mode=\"Markdown\"\n            )\n            return MENU_EDICAO\n            \n    except Exception as e:\n        logger.error(f\"Error in menu_edicao_handler: {e}\")\n        await query.edit_message_text(\"Erro ao processar edi√ß√£o. Tente novamente.\")\n    \n    return MENU_EDICAO\n\nasync def mostrar_previa_completa_bulk(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Show complete preview of all edited messages by actually sending them as previews.\"\"\"\n    try:\n        query = update.callback_query\n        messages = context.user_data.get(\"messages_to_edit\", [])\n        edited_data = context.user_data.get(\"edited_data\", [])\n        added_buttons = context.user_data.get(\"added_buttons\", [])\n        \n        if not messages:\n            await query.edit_message_text(\"‚ùå Nenhuma mensagem encontrada.\")\n            return ConversationHandler.END\n        \n        # Prepare inline keyboard for buttons\n        reply_markup = None\n        if added_buttons:\n            reply_markup = InlineKeyboardMarkup([\n                [InlineKeyboardButton(btn[\"title\"], url=btn[\"url\"])] for btn in added_buttons\n            ])\n        \n        await query.edit_message_text(\"üëÅÔ∏è **Pr√©via das mensagens como ficar√£o no grupo:**\")\n        \n        # Send each message as preview\n        for i, (msg_data, edited_item) in enumerate(zip(messages, edited_data)):\n            try:\n                preview_label = f\"üìã Pr√©via {i+1}:\"\n                await context.bot.send_message(\n                    chat_id=update.effective_chat.id,\n                    text=preview_label\n                )\n                \n                # Send message based on type with preserved formatting\n                if edited_item['media_type'] == 'photo':\n                    await context.bot.send_photo(\n                        chat_id=update.effective_chat.id,\n                        photo=edited_item['file_id'],\n                        caption=edited_item['caption'],\n                        caption_entities=edited_item['caption_entities'],\n                        reply_markup=reply_markup,\n                        parse_mode=None\n                    )\n                elif edited_item['media_type'] == 'video':\n                    await context.bot.send_video(\n                        chat_id=update.effective_chat.id,\n                        video=edited_item['file_id'],\n                        caption=edited_item['caption'],\n                        caption_entities=edited_item['caption_entities'],\n                        reply_markup=reply_markup,\n                        parse_mode=None\n                    )\n                elif edited_item['media_type'] == 'document':\n                    await context.bot.send_document(\n                        chat_id=update.effective_chat.id,\n                        document=edited_item['file_id'],\n                        caption=edited_item['caption'],\n                        caption_entities=edited_item['caption_entities'],\n                        reply_markup=reply_markup,\n                        parse_mode=None\n                    )\n                elif edited_item['media_type'] == 'audio':\n                    await context.bot.send_audio(\n                        chat_id=update.effective_chat.id,\n                        audio=edited_item['file_id'],\n                        caption=edited_item['caption'],\n                        caption_entities=edited_item['caption_entities'],\n                        reply_markup=reply_markup,\n                        parse_mode=None\n                    )\n                elif edited_item['media_type'] == 'voice':\n                    await context.bot.send_voice(\n                        chat_id=update.effective_chat.id,\n                        voice=edited_item['file_id'],\n                        caption=edited_item['caption'],\n                        caption_entities=edited_item['caption_entities'],\n                        reply_markup=reply_markup,\n                        parse_mode=None\n                    )\n                elif edited_item['media_type'] == 'sticker':\n                    await context.bot.send_sticker(\n                        chat_id=update.effective_chat.id,\n                        sticker=edited_item['file_id']\n                    )\n                    # Send caption separately if needed\n                    if edited_item['caption']:\n                        await context.bot.send_message(\n                            chat_id=update.effective_chat.id,\n                            text=edited_item['caption'],\n                            entities=edited_item['caption_entities'],\n                            reply_markup=reply_markup,\n                            parse_mode=None\n                        )\n                else:\n                    # Text message\n                    await context.bot.send_message(\n                        chat_id=update.effective_chat.id,\n                        text=edited_item['text'],\n                        entities=edited_item['entities'],\n                        reply_markup=reply_markup,\n                        parse_mode=None\n                    )\n                \n            except Exception as e:\n                logger.error(f\"Error showing preview for message {i+1}: {e}\")\n                await context.bot.send_message(\n                    chat_id=update.effective_chat.id,\n                    text=f\"‚ùå Erro na pr√©via da mensagem {i+1}\"\n                )\n        \n        # Show confirmation buttons\n        keyboard = [\n            [InlineKeyboardButton(\"‚úÖ Confirmar e enviar todas\", callback_data=\"confirmar_envio_bulk\")],\n            [InlineKeyboardButton(\"üîô Voltar ao menu de edi√ß√£o\", callback_data=\"voltar_edicao\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await context.bot.send_message(\n            chat_id=update.effective_chat.id,\n            text=\"üëÜ **Pr√©vias acima mostram como as mensagens ficar√£o no grupo**\\n\\nConfirmar envio?\",\n            reply_markup=reply_markup,\n            parse_mode=\"Markdown\"\n        )\n        \n        return CONFIRMAR_EDICAO\n        \n    except Exception as e:\n        logger.error(f\"Error showing bulk preview: {e}\")\n        await context.bot.send_message(\n            chat_id=update.effective_chat.id,\n            text=\"‚ùå Erro ao mostrar pr√©via.\"\n        )\n        return MENU_EDICAO\n\nasync def enviar_mensagens_bulk(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Send all collected and edited messages to the destination group.\"\"\"\n    try:\n        query = update.callback_query\n        user_id = update.effective_user.id\n        messages = context.user_data.get(\"messages_to_edit\", [])\n        edited_texts = context.user_data.get(\"edited_texts\", [])\n        added_buttons = context.user_data.get(\"added_buttons\", [])\n        \n        if not messages:\n            await query.edit_message_text(\"‚ùå Nenhuma mensagem encontrada.\")\n            return ConversationHandler.END\n        \n        # Get selected destination from new group system\n        selected_destination = context.user_data.get(\"selected_destination\")\n        if not selected_destination:\n            await query.edit_message_text(\"‚ùå Nenhum grupo de destino selecionado.\")\n            return ConversationHandler.END\n        \n        # Prepare inline keyboard for buttons\n        reply_markup = None\n        if added_buttons:\n            reply_markup = InlineKeyboardMarkup([\n                [InlineKeyboardButton(btn[\"title\"], url=btn[\"url\"])] for btn in added_buttons\n            ])\n        \n        sent_count = 0\n        edited_data = context.user_data.get(\"edited_data\", [])\n        destination_chat_id = selected_destination[\"chat_id\"]\n        \n        for i, (msg_data, edited_item) in enumerate(zip(messages, edited_data)):\n            try:\n                # Send message based on type with preserved formatting\n                if edited_item['media_type'] == 'photo':\n                    await context.bot.send_photo(\n                        chat_id=destination_chat_id,\n                        photo=edited_item['file_id'],\n                        caption=edited_item['caption'],\n                        caption_entities=edited_item['caption_entities'],\n                        reply_markup=reply_markup,\n                        parse_mode=None\n                    )\n                elif edited_item['media_type'] == 'video':\n                    await context.bot.send_video(\n                        chat_id=destination_chat_id,\n                        video=edited_item['file_id'],\n                        caption=edited_item['caption'],\n                        caption_entities=edited_item['caption_entities'],\n                        reply_markup=reply_markup,\n                        parse_mode=None\n                    )\n                elif edited_item['media_type'] == 'document':\n                    await context.bot.send_document(\n                        chat_id=destination_chat_id,\n                        document=edited_item['file_id'],\n                        caption=edited_item['caption'],\n                        caption_entities=edited_item['caption_entities'],\n                        reply_markup=reply_markup,\n                        parse_mode=None\n                    )\n                elif edited_item['media_type'] == 'audio':\n                    await context.bot.send_audio(\n                        chat_id=destination_chat_id,\n                        audio=edited_item['file_id'],\n                        caption=edited_item['caption'],\n                        caption_entities=edited_item['caption_entities'],\n                        reply_markup=reply_markup,\n                        parse_mode=None\n                    )\n                elif edited_item['media_type'] == 'voice':\n                    await context.bot.send_voice(\n                        chat_id=destination_chat_id,\n                        voice=edited_item['file_id'],\n                        caption=edited_item['caption'],\n                        caption_entities=edited_item['caption_entities'],\n                        reply_markup=reply_markup,\n                        parse_mode=None\n                    )\n                elif edited_item['media_type'] == 'sticker':\n                    await context.bot.send_sticker(\n                        chat_id=destination_chat_id,\n                        sticker=edited_item['file_id']\n                    )\n                    # Send caption separately if needed\n                    if edited_item['caption']:\n                        await context.bot.send_message(\n                            chat_id=destination_chat_id,\n                            text=edited_item['caption'],\n                            entities=edited_item['caption_entities'],\n                            reply_markup=reply_markup,\n                            parse_mode=None\n                        )\n                else:\n                    # Text message\n                    await context.bot.send_message(\n                        chat_id=destination_chat_id,\n                        text=edited_item['text'],\n                        entities=edited_item['entities'],\n                        reply_markup=reply_markup,\n                        parse_mode=None\n                    )\n                \n                sent_count += 1\n                \n            except Exception as e:\n                logger.error(f\"Error sending message {i+1}: {e}\")\n                continue\n        \n        # Clear temporary storage\n        if user_id in context.bot_data.get('mensagens_temp', {}):\n            del context.bot_data['mensagens_temp'][user_id]\n        \n        # Clear user data\n        context.user_data.clear()\n        \n        # Show success message\n        keyboard = [[InlineKeyboardButton(\"üè† Voltar ao Menu Principal\", callback_data=\"voltar_menu\")]]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(\n            f\"‚úÖ **Envio conclu√≠do!**\\n\\n\"\n            f\"Mensagens enviadas: {sent_count}/{len(messages)}\\n\"\n            f\"Grupo de destino: {selected_destination['name']}\",\n            reply_markup=reply_markup,\n            parse_mode=\"Markdown\"\n        )\n        \n        return ConversationHandler.END\n        \n    except Exception as e:\n        logger.error(f\"Error sending bulk messages: {e}\")\n        await update.callback_query.edit_message_text(\"‚ùå Erro ao enviar mensagens.\")\n        return ConversationHandler.END\n\nasync def encaminhamento_callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Handle callback queries for group management and destination selection.\"\"\"\n    query = update.callback_query\n    \n    # Always answer callback, ignore if expired\n    try:\n        await query.answer()\n    except Exception:\n        # Ignore expired callbacks, continue processing\n        pass\n    \n    try:\n        if query.data == \"voltar_menu\":\n            from handlers.message_handlers import start\n            await start(update, context)\n            return ConversationHandler.END\n            \n        elif query.data == \"cadastrar_grupo\":\n            from handlers.message_handlers import cadastrar_novo_grupo\n            return await cadastrar_novo_grupo(update, context)\n            \n        elif query.data == \"ver_grupos\":\n            from handlers.message_handlers import mostrar_grupos_cadastrados\n            return await mostrar_grupos_cadastrados(update, context)\n            \n        elif query.data == \"gerenciar_grupos\":\n            from handlers.message_handlers import mostrar_menu_gerenciar_grupos\n            return await mostrar_menu_gerenciar_grupos(update, context)\n            \n        elif query.data.startswith(\"confirmar_cadastro_\"):\n            # Extract chat_id from callback data\n            chat_id = query.data.replace(\"confirmar_cadastro_\", \"\")\n            try:\n                chat_id = int(chat_id) if chat_id.startswith(\"-\") else chat_id\n            except ValueError:\n                pass  # Keep as string for channel usernames\n            \n            # Initialize grupos if not exists\n            if \"grupos\" not in context.user_data:\n                context.user_data[\"grupos\"] = []\n            \n            # Get pending group data\n            pending_group = context.user_data.get(\"pending_group\")\n            if not pending_group:\n                await query.edit_message_text(\"‚ùå Dados do grupo n√£o encontrados. Tente novamente.\")\n                return ConversationHandler.END\n            \n            # Check for duplicates\n            grupos_existentes = context.user_data[\"grupos\"]\n            for grupo in grupos_existentes:\n                if str(grupo[\"chat_id\"]) == str(chat_id):\n                    await query.edit_message_text(\n                        f\"‚ùå **Grupo j√° cadastrado**\\n\\n\"\n                        f\"O grupo `{chat_id}` j√° est√° na sua lista como '{grupo['name']}'.\",\n                        parse_mode=\"Markdown\"\n                    )\n                    # Show main menu automatically\n                    from handlers.message_handlers import start\n                    await start(update, context)\n                    return ConversationHandler.END\n            \n            # Add group to user's list\n            context.user_data[\"grupos\"].append({\n                \"chat_id\": chat_id,\n                \"name\": pending_group[\"name\"]\n            })\n            \n            # Clear pending data\n            if \"pending_group\" in context.user_data:\n                del context.user_data[\"pending_group\"]\n            \n            # Show success message\n            await query.edit_message_text(\n                f\"‚úÖ **Grupo adicionado com sucesso!**\\n\\n\"\n                f\"**Nome:** {pending_group['name']}\\n\"\n                f\"**ID:** `{chat_id}`\\n\\n\"\n                f\"Total de grupos: {len(context.user_data['grupos'])}\",\n                parse_mode=\"Markdown\"\n            )\n            \n            # Automatically show main menu after success\n            from handlers.message_handlers import start\n            await start(update, context)\n            \n            return ConversationHandler.END\n            \n        elif query.data.startswith(\"destino_\"):\n            # Handle destination selection for message sending\n            parts = query.data.split(\"_\")\n            action_type = parts[1]  # \"envio\" or \"repassar\"\n            grupo_index = int(parts[2])\n            \n            grupos = context.user_data.get(\"grupos\", [])\n            if grupo_index >= len(grupos):\n                await query.edit_message_text(\"‚ùå Grupo n√£o encontrado.\")\n                return ConversationHandler.END\n            \n            selected_group = grupos[grupo_index]\n            context.user_data[\"selected_destination\"] = selected_group\n            \n            # Proceed based on action type\n            if action_type == \"envio\":\n                # Show message creation menu\n                keyboard = [\n                    [InlineKeyboardButton(\"üì∑ M√≠dia\", callback_data=\"midia\")],\n                    [InlineKeyboardButton(\"üìù Texto\", callback_data=\"texto\")],\n                    [InlineKeyboardButton(\"üîó Bot√µes\", callback_data=\"botoes\")],\n                    [InlineKeyboardButton(\"üîô Voltar\", callback_data=\"voltar_menu\")]\n                ]\n                reply_markup = InlineKeyboardMarkup(keyboard)\n                \n                await query.edit_message_text(\n                    f\"‚úÖ **Destino selecionado:** {selected_group['name']}\\n\\n\"\n                    \"Escolha o tipo de conte√∫do para enviar:\",\n                    reply_markup=reply_markup,\n                    parse_mode=\"Markdown\"\n                )\n                return MENU_ENVIO\n                \n            elif action_type == \"repassar\":\n                # Start collecting messages for forwarding\n                await query.edit_message_text(\n                    f\"‚úÖ **Destino selecionado:** {selected_group['name']}\\n\\n\"\n                    \"üì® Agora envie as mensagens que deseja repassar.\\n\\n\"\n                    \"Use /finalizar quando terminar de enviar todas as mensagens.\",\n                    parse_mode=\"Markdown\"\n                )\n                return RECEBER_ENCAMINHADAS\n                \n        elif query.data.startswith(\"remover_grupo_\"):\n            # Handle group removal\n            grupo_index = int(query.data.replace(\"remover_grupo_\", \"\"))\n            grupos = context.user_data.get(\"grupos\", [])\n            \n            if grupo_index >= len(grupos):\n                await query.edit_message_text(\"‚ùå Grupo n√£o encontrado.\")\n                return ConversationHandler.END\n            \n            grupo_removido = grupos.pop(grupo_index)\n            \n            keyboard = [[InlineKeyboardButton(\"üè† Voltar ao Menu Principal\", callback_data=\"voltar_menu\")]]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await query.edit_message_text(\n                f\"‚úÖ **Grupo removido**\\n\\n\"\n                f\"**Nome:** {grupo_removido['name']}\\n\"\n                f\"**ID:** `{grupo_removido['chat_id']}`\\n\\n\"\n                f\"Grupos restantes: {len(grupos)}\",\n                reply_markup=reply_markup,\n                parse_mode=\"Markdown\"\n            )\n            return ConversationHandler.END\n            \n    except Exception as e:\n        logger.error(f\"Error in encaminhamento_callback_handler: {e}\")\n        await query.edit_message_text(\"‚ùå Erro ao processar a√ß√£o. Tente novamente.\")\n        return ConversationHandler.END\n\nasync def global_callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Handle callback queries outside of conversations (for menu navigation).\"\"\"\n    query = update.callback_query\n    \n    # Always answer callback immediately to prevent loading state\n    try:\n        await query.answer()\n    except Exception as e:\n        logger.warning(f\"Failed to answer callback: {e}\")\n        # If callback is expired, send new message\n        try:\n            await query.message.reply_text(\"‚ö†Ô∏è Essa a√ß√£o expirou. Abra o menu novamente enviando qualquer mensagem.\")\n            return\n        except Exception:\n            return\n    \n    try:\n        # Handle main menu options\n        if query.data == \"opcao1\":\n            from handlers.message_handlers import mostrar_menu_gerenciar_grupos\n            await mostrar_menu_gerenciar_grupos(update, context)\n        elif query.data == \"opcao2\":\n            await query.edit_message_text(\"Voc√™ selecionou: Lista de cursos\")\n        elif query.data == \"opcao3\":\n            await query.edit_message_text(\"Voc√™ selecionou: Grupo VIP\")\n        elif query.data == \"opcao4\":\n            # Check if there are groups registered\n            grupos = context.user_data.get(\"grupos\", [])\n            if not grupos:\n                keyboard = [[InlineKeyboardButton(\"üè† Voltar ao Menu Principal\", callback_data=\"voltar_menu\")]]\n                reply_markup = InlineKeyboardMarkup(keyboard)\n                await query.edit_message_text(\n                    \"‚ùå Nenhum grupo cadastrado.\\n\\n\"\n                    \"Use a op√ß√£o 'Gerenciar grupos' primeiro.\",\n                    reply_markup=reply_markup\n                )\n            else:\n                from handlers.message_handlers import mostrar_selecao_destinos\n                await mostrar_selecao_destinos(update, context, \"envio\")\n        elif query.data == \"opcao5\":\n            # Check if there are groups registered\n            grupos = context.user_data.get(\"grupos\", [])\n            if not grupos:\n                keyboard = [[InlineKeyboardButton(\"üè† Voltar ao Menu Principal\", callback_data=\"voltar_menu\")]]\n                reply_markup = InlineKeyboardMarkup(keyboard)\n                await query.edit_message_text(\n                    \"‚ùå Nenhum grupo cadastrado.\\n\\n\"\n                    \"Use a op√ß√£o 'Gerenciar grupos' primeiro.\",\n                    reply_markup=reply_markup\n                )\n            else:\n                from handlers.message_handlers import mostrar_selecao_destinos\n                await mostrar_selecao_destinos(update, context, \"repassar\")\n        elif query.data == \"voltar_menu\":\n            from handlers.message_handlers import start\n            await start(update, context)\n    except Exception as e:\n        logger.error(f\"Error in global_callback_handler: {e}\")\n        await query.edit_message_text(\"Erro ao processar sele√ß√£o. Tente novamente.\")\n\nasync def handle_any_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Handle any message outside of conversations - only in private chats.\"\"\"\n    try:\n        # Only respond in private chats\n        if update.message.chat.type != \"private\":\n            return\n            \n        # Show main menu\n        from handlers.message_handlers import start\n        await start(update, context)\n    except Exception as e:\n        logger.error(f\"Error in handle_any_message: {e}\")","size_bytes":50816},"handlers/message_handlers.py":{"content":"from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import ContextTypes, ConversationHandler\nfrom config import GROUP_CHAT_ID, RECEBER_MIDIA, RECEBER_TEXTO, RECEBER_BOTOES, CONFIRMAR_PREVIA, RECEBER_ENCAMINHADAS, FORWARD_COLLECT, RECEBER_LINK, CONFIRMAR_REPASSAR, CADASTRAR_GRUPO, SELECIONAR_GRUPO, CONFIRMAR_GRUPO, MENU_EDICAO, ADICIONAR_TEXTO, ADICIONAR_BOTAO_TITULO, ADICIONAR_BOTAO_LINK, REMOVER_PALAVRA, CONFIRMAR_EDICAO\nfrom utils.validators import validate_button_format, validate_telegram_link\nfrom utils.storage import get_destination_group, set_destination_group, get_destination_groups, add_destination_group, remove_destination_group\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Send main menu when the command /start is issued.\"\"\"\n    keyboard = [\n        [InlineKeyboardButton(\"1 ‚Äì Gerenciar grupos\", callback_data=\"opcao1\")],\n        [InlineKeyboardButton(\"2 ‚Äì Lista de cursos\", callback_data=\"opcao2\")],\n        [InlineKeyboardButton(\"3 ‚Äì Grupo VIP\", callback_data=\"opcao3\")],\n        [InlineKeyboardButton(\"4 ‚Äì Enviar mensagem\", callback_data=\"opcao4\")],\n        [InlineKeyboardButton(\"5 ‚Äì Repassar mensagens\", callback_data=\"opcao5\")]\n    ]\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    \n    if update.message:\n        await update.message.reply_text(\"Escolha uma op√ß√£o:\", reply_markup=reply_markup)\n    elif update.callback_query:\n        await update.callback_query.edit_message_text(\"Escolha uma op√ß√£o:\", reply_markup=reply_markup)\n\nasync def receber_midia(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Handle media (photo or video) upload.\"\"\"\n    try:\n        if update.message.photo:\n            file_id = update.message.photo[-1].file_id\n            context.user_data[\"midia\"] = (\"photo\", file_id)\n            logger.info(f\"Photo received: {file_id}\")\n        elif update.message.video:\n            file_id = update.message.video.file_id\n            context.user_data[\"midia\"] = (\"video\", file_id)\n            logger.info(f\"Video received: {file_id}\")\n        else:\n            await update.message.reply_text(\"Por favor, envie uma foto ou v√≠deo.\")\n            return RECEBER_MIDIA\n        \n        await update.message.reply_text(\"Agora envie o texto da mensagem:\")\n        return RECEBER_TEXTO\n    except Exception as e:\n        logger.error(f\"Error receiving media: {e}\")\n        await update.message.reply_text(\"Erro ao processar m√≠dia. Tente novamente.\")\n        return RECEBER_MIDIA\n\nasync def receber_texto(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Handle text input for message content.\"\"\"\n    try:\n        text = update.message.text\n        if len(text) > 1000:  # Reasonable limit for caption\n            await update.message.reply_text(\"Texto muito longo. Limite de 1000 caracteres.\")\n            return RECEBER_TEXTO\n        \n        context.user_data[\"texto\"] = text\n        await update.message.reply_text(\n            \"Agora envie os bot√µes no formato:\\n\\n\"\n            \"NOME1|LINK1, NOME2|LINK2\\n\\n\"\n            \"Exemplo:\\nVIP|https://t.me/grupovip, Cursos|https://t.me/cursos\"\n        )\n        return RECEBER_BOTOES\n    except Exception as e:\n        logger.error(f\"Error receiving text: {e}\")\n        await update.message.reply_text(\"Erro ao processar texto. Tente novamente.\")\n        return RECEBER_TEXTO\n\nasync def receber_botoes(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Handle button format input and validate.\"\"\"\n    try:\n        texto = update.message.text\n        botoes = validate_button_format(texto)\n        \n        if botoes is None:\n            await update.message.reply_text(\n                \"Formato inv√°lido. Envie os bot√µes como: NOME|LINK, NOME2|LINK2\\n\"\n                \"Certifique-se de que todos os links s√£o v√°lidos.\"\n            )\n            return RECEBER_BOTOES\n        \n        context.user_data[\"botoes\"] = botoes\n        await mostrar_previa(update, context)\n        return CONFIRMAR_PREVIA\n    except Exception as e:\n        logger.error(f\"Error receiving buttons: {e}\")\n        await update.message.reply_text(\"Erro ao processar bot√µes. Tente novamente.\")\n        return RECEBER_BOTOES\n\nasync def mostrar_previa(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Show preview of the message to be sent.\"\"\"\n    try:\n        midia = context.user_data.get(\"midia\")\n        texto = context.user_data.get(\"texto\", \"\")\n        botoes = context.user_data.get(\"botoes\", [])\n        \n        reply_markup = None\n        if botoes:\n            reply_markup = InlineKeyboardMarkup(\n                [[InlineKeyboardButton(nome, url=link)] for nome, link in botoes]\n            )\n        \n        # Send preview exactly as it will be posted\n        if midia:\n            tipo, file_id = midia\n            if tipo == \"photo\":\n                await update.message.reply_photo(\n                    photo=file_id, \n                    caption=texto, \n                    reply_markup=reply_markup\n                )\n            elif tipo == \"video\":\n                await update.message.reply_video(\n                    video=file_id, \n                    caption=texto, \n                    reply_markup=reply_markup\n                )\n        else:\n            await update.message.reply_text(texto, reply_markup=reply_markup)\n        \n        # Confirmation menu\n        keyboard = [\n            [InlineKeyboardButton(\"Confirmar\", callback_data=\"sim\")],\n            [InlineKeyboardButton(\"Editar\", callback_data=\"editar\")]\n        ]\n        reply_markup_confirm = InlineKeyboardMarkup(keyboard)\n        await update.message.reply_text(\"Est√° correto?\", reply_markup=reply_markup_confirm)\n    except Exception as e:\n        logger.error(f\"Error showing preview: {e}\")\n        await update.message.reply_text(\"Erro ao mostrar pr√©via. Tente novamente.\")\n\nasync def receber_encaminhadas(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Handle forwarded messages for option 5 - collect multiple messages.\"\"\"\n    try:\n        msg = update.message\n        \n        # Get destination group\n        from utils.storage import get_destination_group\n        destination_group = get_destination_group()\n        \n        if not destination_group:\n            keyboard = [[InlineKeyboardButton(\"üè† Voltar ao Menu Principal\", callback_data=\"voltar_menu\")]]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await msg.reply_text(\n                \"‚ùå Nenhum grupo de destino cadastrado.\\n\\n\"\n                \"Use a op√ß√£o 'Cadastrar grupo de destino' primeiro.\",\n                reply_markup=reply_markup\n            )\n            return ConversationHandler.END\n        \n        # Check for protected content\n        if getattr(msg, \"has_protected_content\", False):\n            await msg.reply_text(\"Conte√∫do protegido contra c√≥pia. Envie outro item.\")\n            return FORWARD_COLLECT\n        \n        # Initialize message collection for this user\n        user_id = update.effective_user.id\n        if 'mensagens_temp' not in context.bot_data:\n            context.bot_data['mensagens_temp'] = {}\n        \n        if user_id not in context.bot_data['mensagens_temp']:\n            context.bot_data['mensagens_temp'][user_id] = []\n        \n        # Store the original message with all formatting preserved\n        message_data = {\n            'message': msg,\n            'text': msg.text,\n            'caption': msg.caption,\n            'entities': msg.entities,\n            'caption_entities': msg.caption_entities,\n            'file_id': None,\n            'media_type': None\n        }\n        \n        # Extract file_id and media type for different message types\n        if msg.photo:\n            message_data['file_id'] = msg.photo[-1].file_id\n            message_data['media_type'] = 'photo'\n        elif msg.video:\n            message_data['file_id'] = msg.video.file_id\n            message_data['media_type'] = 'video'\n        elif msg.document:\n            message_data['file_id'] = msg.document.file_id\n            message_data['media_type'] = 'document'\n        elif msg.audio:\n            message_data['file_id'] = msg.audio.file_id\n            message_data['media_type'] = 'audio'\n        elif msg.voice:\n            message_data['file_id'] = msg.voice.file_id\n            message_data['media_type'] = 'voice'\n        elif msg.sticker:\n            message_data['file_id'] = msg.sticker.file_id\n            message_data['media_type'] = 'sticker'\n        else:\n            message_data['media_type'] = 'text'\n        \n        context.bot_data['mensagens_temp'][user_id].append(message_data)\n        \n        # Show collection status and continue/finish options\n        total_messages = len(context.bot_data['mensagens_temp'][user_id])\n        keyboard = [\n            [InlineKeyboardButton(\"‚úÖ Finalizar e editar\", callback_data=\"finalizar_coleta\")],\n            [InlineKeyboardButton(\"üîÑ Continuar enviando\", callback_data=\"continuar_coleta\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await msg.reply_text(\n            f\"üì• Mensagem {total_messages} salva!\\n\\n\"\n            f\"Total de mensagens: {total_messages}\\n\\n\"\n            \"Deseja continuar enviando mensagens ou finalizar para editar todas de uma vez?\",\n            reply_markup=reply_markup\n        )\n        \n        return FORWARD_COLLECT\n        \n    except Exception as e:\n        logger.error(f\"Error receiving forwarded messages: {e}\")\n        await update.message.reply_text(\"Erro ao processar mensagem.\")\n        return FORWARD_COLLECT\n\nasync def adicionar_texto_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Handle adding text to all messages in bulk editing.\"\"\"\n    try:\n        text_to_add = update.message.text\n        edited_data = context.user_data.get(\"edited_data\", [])\n        \n        # Add text to all messages\n        for item in edited_data:\n            if item['media_type'] == 'text':\n                # For text messages, append to text\n                if item['text']:\n                    item['text'] = item['text'] + \"\\n\\n\" + text_to_add\n                else:\n                    item['text'] = text_to_add\n            else:\n                # For media messages, append to caption\n                if item['caption']:\n                    item['caption'] = item['caption'] + \"\\n\\n\" + text_to_add\n                else:\n                    item['caption'] = text_to_add\n        \n        context.user_data[\"edited_data\"] = edited_data\n        \n        await update.message.reply_text(\"‚úÖ Texto adicionado a todas as mensagens! Voltando ao menu de edi√ß√£o...\")\n        \n        # Show bulk editing menu again\n        messages = context.user_data.get(\"messages_to_edit\", [])\n        keyboard = [\n            [InlineKeyboardButton(\"‚úèÔ∏è Adicionar texto a todas\", callback_data=\"adicionar_texto_bulk\")],\n            [InlineKeyboardButton(\"üîó Adicionar bot√£o a todas\", callback_data=\"adicionar_botao_bulk\")],\n            [InlineKeyboardButton(\"üóëÔ∏è Remover palavra de todas\", callback_data=\"remover_palavra_bulk\")],\n            [InlineKeyboardButton(\"üëÅÔ∏è Ver pr√©via de todas\", callback_data=\"previa_bulk\")],\n            [InlineKeyboardButton(\"üì§ Enviar todas sem editar\", callback_data=\"enviar_bulk\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        total = len(messages)\n        await update.message.reply_text(\n            f\"üìù **Menu de Edi√ß√£o em Lote**\\n\\n\"\n            f\"Total de mensagens: {total}\\n\\n\"\n            \"Escolha como deseja editar todas as mensagens:\",\n            reply_markup=reply_markup,\n            parse_mode=\"Markdown\"\n        )\n        \n        return MENU_EDICAO\n        \n    except Exception as e:\n        logger.error(f\"Error adding text: {e}\")\n        await update.message.reply_text(\"Erro ao adicionar texto. Tente novamente.\")\n        return MENU_EDICAO\n\nasync def adicionar_botao_titulo_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Handle button title input.\"\"\"\n    try:\n        context.user_data[\"button_title\"] = update.message.text\n        await update.message.reply_text(\"üí¨ Agora envie o link do bot√£o:\")\n        return ADICIONAR_BOTAO_LINK\n        \n    except Exception as e:\n        logger.error(f\"Error handling button title: {e}\")\n        await update.message.reply_text(\"Erro ao processar t√≠tulo. Tente novamente.\")\n        return ADICIONAR_BOTAO_TITULO\n\nasync def adicionar_botao_link_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Handle button link input and add button to all messages.\"\"\"\n    try:\n        button_link = update.message.text\n        button_title = context.user_data.get(\"button_title\", \"\")\n        \n        # Validate URL\n        if not (button_link.startswith(\"http://\") or button_link.startswith(\"https://\")):\n            await update.message.reply_text(\"‚ùå Link inv√°lido. Use um link completo (http:// ou https://)\")\n            return ADICIONAR_BOTAO_LINK\n        \n        # Add button to list (will be applied to all messages)\n        if \"added_buttons\" not in context.user_data:\n            context.user_data[\"added_buttons\"] = []\n        \n        context.user_data[\"added_buttons\"].append({\n            \"title\": button_title,\n            \"url\": button_link\n        })\n        \n        await update.message.reply_text(\"‚úÖ Bot√£o adicionado a todas as mensagens! Voltando ao menu de edi√ß√£o...\")\n        \n        # Show bulk editing menu again\n        messages = context.user_data.get(\"messages_to_edit\", [])\n        keyboard = [\n            [InlineKeyboardButton(\"‚úèÔ∏è Adicionar texto a todas\", callback_data=\"adicionar_texto_bulk\")],\n            [InlineKeyboardButton(\"üîó Adicionar bot√£o a todas\", callback_data=\"adicionar_botao_bulk\")],\n            [InlineKeyboardButton(\"üóëÔ∏è Remover palavra de todas\", callback_data=\"remover_palavra_bulk\")],\n            [InlineKeyboardButton(\"üëÅÔ∏è Ver pr√©via de todas\", callback_data=\"previa_bulk\")],\n            [InlineKeyboardButton(\"üì§ Enviar todas sem editar\", callback_data=\"enviar_bulk\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        total = len(messages)\n        await update.message.reply_text(\n            f\"üìù **Menu de Edi√ß√£o em Lote**\\n\\n\"\n            f\"Total de mensagens: {total}\\n\\n\"\n            \"Escolha como deseja editar todas as mensagens:\",\n            reply_markup=reply_markup,\n            parse_mode=\"Markdown\"\n        )\n        \n        return MENU_EDICAO\n        \n    except Exception as e:\n        logger.error(f\"Error adding button: {e}\")\n        await update.message.reply_text(\"Erro ao adicionar bot√£o. Tente novamente.\")\n        return ADICIONAR_BOTAO_LINK\n\nasync def remover_palavra_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Handle word removal from all messages.\"\"\"\n    try:\n        word_to_remove = update.message.text.strip()\n        edited_data = context.user_data.get(\"edited_data\", [])\n        \n        # Remove word from all messages\n        for item in edited_data:\n            if item['media_type'] == 'text' and item['text']:\n                # Remove from text content\n                updated_text = item['text'].replace(word_to_remove, \"\")\n                updated_text = \" \".join(updated_text.split())\n                item['text'] = updated_text\n            elif item['caption']:\n                # Remove from caption content\n                updated_caption = item['caption'].replace(word_to_remove, \"\")\n                updated_caption = \" \".join(updated_caption.split())\n                item['caption'] = updated_caption\n        \n        context.user_data[\"edited_data\"] = edited_data\n        \n        await update.message.reply_text(f\"‚úÖ Palavra '{word_to_remove}' removida de todas as mensagens! Voltando ao menu de edi√ß√£o...\")\n        \n        # Show bulk editing menu again\n        messages = context.user_data.get(\"messages_to_edit\", [])\n        keyboard = [\n            [InlineKeyboardButton(\"‚úèÔ∏è Adicionar texto a todas\", callback_data=\"adicionar_texto_bulk\")],\n            [InlineKeyboardButton(\"üîó Adicionar bot√£o a todas\", callback_data=\"adicionar_botao_bulk\")],\n            [InlineKeyboardButton(\"üóëÔ∏è Remover palavra de todas\", callback_data=\"remover_palavra_bulk\")],\n            [InlineKeyboardButton(\"üëÅÔ∏è Ver pr√©via de todas\", callback_data=\"previa_bulk\")],\n            [InlineKeyboardButton(\"üì§ Enviar todas sem editar\", callback_data=\"enviar_bulk\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        total = len(messages)\n        await update.message.reply_text(\n            f\"üìù **Menu de Edi√ß√£o em Lote**\\n\\n\"\n            f\"Total de mensagens: {total}\\n\\n\"\n            \"Escolha como deseja editar todas as mensagens:\",\n            reply_markup=reply_markup,\n            parse_mode=\"Markdown\"\n        )\n        \n        return MENU_EDICAO\n        \n    except Exception as e:\n        logger.error(f\"Error removing word: {e}\")\n        await update.message.reply_text(\"Erro ao remover palavra. Tente novamente.\")\n        return REMOVER_PALAVRA\n\nasync def mostrar_previa_edicao(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Show preview of edited message.\"\"\"\n    try:\n        original_msg = context.user_data[\"original_message\"]\n        edited_text = context.user_data.get(\"edited_text\", \"\")\n        added_buttons = context.user_data.get(\"added_buttons\", [])\n        \n        # Create preview message\n        preview_text = \"üìã **Pr√©via da mensagem editada:**\\n\\n\"\n        \n        if edited_text:\n            preview_text += edited_text\n        else:\n            preview_text += \"_[Mensagem sem texto]_\"\n        \n        # Create reply markup with added buttons\n        keyboard = []\n        for button in added_buttons:\n            keyboard.append([InlineKeyboardButton(button[\"title\"], url=button[\"url\"])])\n        \n        # Add confirmation buttons\n        keyboard.extend([\n            [InlineKeyboardButton(\"‚úÖ Confirmar envio\", callback_data=\"confirmar_envio\")],\n            [InlineKeyboardButton(\"‚úèÔ∏è Editar novamente\", callback_data=\"editar_novamente\")]\n        ])\n        \n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        # Show preview\n        if original_msg.photo or original_msg.video or original_msg.document or original_msg.audio:\n            # For media messages, show media with edited caption\n            if original_msg.photo:\n                await original_msg.reply_photo(\n                    photo=original_msg.photo[-1].file_id,\n                    caption=preview_text,\n                    reply_markup=reply_markup,\n                    parse_mode=\"Markdown\"\n                )\n            elif original_msg.video:\n                await original_msg.reply_video(\n                    video=original_msg.video.file_id,\n                    caption=preview_text,\n                    reply_markup=reply_markup,\n                    parse_mode=\"Markdown\"\n                )\n            elif original_msg.document:\n                await original_msg.reply_document(\n                    document=original_msg.document.file_id,\n                    caption=preview_text,\n                    reply_markup=reply_markup,\n                    parse_mode=\"Markdown\"\n                )\n            elif original_msg.audio:\n                await original_msg.reply_audio(\n                    audio=original_msg.audio.file_id,\n                    caption=preview_text,\n                    reply_markup=reply_markup,\n                    parse_mode=\"Markdown\"\n                )\n        else:\n            # For text messages\n            await original_msg.reply_text(\n                preview_text,\n                reply_markup=reply_markup,\n                parse_mode=\"Markdown\"\n            )\n        \n        return CONFIRMAR_EDICAO\n        \n    except Exception as e:\n        logger.error(f\"Error showing preview: {e}\")\n        await update.message.reply_text(\"Erro ao mostrar pr√©via. Tente novamente.\")\n        return MENU_EDICAO\n\nasync def enviar_mensagem_editada(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Send the edited message to destination group.\"\"\"\n    try:\n        original_msg = context.user_data[\"original_message\"]\n        destination_group = context.user_data[\"destination_group\"]\n        edited_text = context.user_data.get(\"edited_text\", \"\")\n        added_buttons = context.user_data.get(\"added_buttons\", [])\n        \n        # Create reply markup with added buttons\n        reply_markup = None\n        if added_buttons:\n            keyboard = []\n            for button in added_buttons:\n                keyboard.append([InlineKeyboardButton(button[\"title\"], url=button[\"url\"])])\n            reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        # Check if message was edited (has new text or buttons)\n        was_edited = (edited_text != (original_msg.text or original_msg.caption or \"\")) or added_buttons\n        \n        if was_edited:\n            # Send as new message with edited content\n            if original_msg.photo:\n                await context.bot.send_photo(\n                    chat_id=destination_group,\n                    photo=original_msg.photo[-1].file_id,\n                    caption=edited_text,\n                    reply_markup=reply_markup\n                )\n            elif original_msg.video:\n                await context.bot.send_video(\n                    chat_id=destination_group,\n                    video=original_msg.video.file_id,\n                    caption=edited_text,\n                    reply_markup=reply_markup\n                )\n            elif original_msg.document:\n                await context.bot.send_document(\n                    chat_id=destination_group,\n                    document=original_msg.document.file_id,\n                    caption=edited_text,\n                    reply_markup=reply_markup\n                )\n            elif original_msg.audio:\n                await context.bot.send_audio(\n                    chat_id=destination_group,\n                    audio=original_msg.audio.file_id,\n                    caption=edited_text,\n                    reply_markup=reply_markup\n                )\n            elif original_msg.voice:\n                # Voice notes can't have captions, so send text separately if edited\n                await context.bot.send_voice(\n                    chat_id=destination_group,\n                    voice=original_msg.voice.file_id\n                )\n                if edited_text:\n                    await context.bot.send_message(\n                        chat_id=destination_group,\n                        text=edited_text,\n                        reply_markup=reply_markup\n                    )\n            else:\n                # Text message\n                await context.bot.send_message(\n                    chat_id=destination_group,\n                    text=edited_text,\n                    reply_markup=reply_markup\n                )\n        else:\n            # Use copy_message for unedited content\n            await context.bot.copy_message(\n                chat_id=destination_group,\n                from_chat_id=original_msg.chat_id,\n                message_id=original_msg.message_id\n            )\n        \n        # Show success message\n        keyboard = [[InlineKeyboardButton(\"üè† Voltar ao Menu Principal\", callback_data=\"voltar_menu\")]]\n        reply_markup_success = InlineKeyboardMarkup(keyboard)\n        \n        await update.callback_query.edit_message_text(\n            \"‚úÖ Mensagem enviada com sucesso!\",\n            reply_markup=reply_markup_success\n        )\n        \n        # Clean up user data\n        context.user_data.pop(\"original_message\", None)\n        context.user_data.pop(\"edited_text\", None)\n        context.user_data.pop(\"added_buttons\", None)\n        context.user_data.pop(\"button_title\", None)\n        \n        return ConversationHandler.END\n        \n    except Exception as e:\n        logger.error(f\"Error sending edited message: {e}\")\n        await update.callback_query.edit_message_text(\"‚ùå Erro ao enviar mensagem.\")\n        return ConversationHandler.END\n\nasync def atualizar_menu_encaminhamento(context, chat_id, menu_msg_id, total):\n    \"\"\"Update the forwarding menu with current count.\"\"\"\n    try:\n        keyboard = [\n            [InlineKeyboardButton(\"Adicionar mais mensagens\", callback_data=\"add_msgs\")],\n            [InlineKeyboardButton(f\"Finalizar ({total} coletados)\", callback_data=\"finalizar_encaminhamento\")],\n            [InlineKeyboardButton(\"Cancelar\", callback_data=\"cancelar_encaminhamento\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await context.bot.edit_message_reply_markup(\n            chat_id=chat_id,\n            message_id=menu_msg_id,\n            reply_markup=reply_markup\n        )\n    except Exception as e:\n        logger.error(f\"Error updating forwarding menu: {e}\")\n\nasync def comando_pronto(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Handle /pronto command to finish collecting messages.\"\"\"\n    try:\n        total_items = len(context.user_data.get(\"forwarded_items\", [])) + sum(\n            len(g) for g in context.user_data.get(\"media_groups\", {}).values()\n        )\n        \n        if total_items == 0:\n            await update.message.reply_text(\n                \"Voc√™ n√£o encaminhou nenhuma mensagem. Encaminhe ao menos uma antes de digitar /pronto.\"\n            )\n            return RECEBER_ENCAMINHADAS\n        \n        await update.message.reply_text(\"Agora envie o link de destino (grupo, canal ou chat):\")\n        return RECEBER_LINK\n    except Exception as e:\n        logger.error(f\"Error in comando_pronto: {e}\")\n        await update.message.reply_text(\"Erro ao processar comando. Tente novamente.\")\n        return RECEBER_ENCAMINHADAS\n\nasync def receber_link(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Handle destination link input.\"\"\"\n    try:\n        link = update.message.text.strip()\n        \n        if not validate_telegram_link(link):\n            await update.message.reply_text(\n                \"Link inv√°lido. Envie um link do Telegram v√°lido (t.me/username) ou ID do chat.\"\n            )\n            return RECEBER_LINK\n        \n        context.user_data[\"link_destino\"] = link\n        \n        # Show confirmation with summary\n        total_items = len(context.user_data.get(\"forwarded_items\", [])) + sum(\n            len(g) for g in context.user_data.get(\"media_groups\", {}).values()\n        )\n        \n        keyboard = [\n            [InlineKeyboardButton(\"Confirmar envio\", callback_data=\"confirmar_repassar\")],\n            [InlineKeyboardButton(\"Cancelar\", callback_data=\"cancelar_repassar\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(\n            f\"Destino: {link}\\n\"\n            f\"Total de itens: {total_items}\\n\\n\"\n            f\"Confirma o envio?\",\n            reply_markup=reply_markup\n        )\n        \n        return CONFIRMAR_REPASSAR\n    except Exception as e:\n        logger.error(f\"Error receiving link: {e}\")\n        await update.message.reply_text(\"Erro ao processar link. Tente novamente.\")\n        return RECEBER_LINK\n\nasync def handle_any_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Handle any message that doesn't match other handlers - show main menu.\"\"\"\n    # Only react to messages in private chat\n    if update.message.chat.type != \"private\":\n        return\n    \n    await start(update, context)\n\nasync def mostrar_menu_gerenciar_grupos(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Show group management menu.\"\"\"\n    try:\n        query = update.callback_query\n        await query.answer()\n        \n        # Initialize grupos if not exists\n        if \"grupos\" not in context.user_data:\n            context.user_data[\"grupos\"] = []\n        \n        grupos = context.user_data[\"grupos\"]\n        total_grupos = len(grupos)\n        \n        keyboard = [\n            [InlineKeyboardButton(\"‚ûï Cadastrar grupo\", callback_data=\"cadastrar_grupo\")],\n            [InlineKeyboardButton(f\"üìã Ver grupos cadastrados ({total_grupos})\", callback_data=\"ver_grupos\")],\n            [InlineKeyboardButton(\"üè† Voltar ao Menu Principal\", callback_data=\"voltar_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(\n            \"üìÇ **Gerenciar Grupos**\\n\\n\"\n            f\"Grupos cadastrados: {total_grupos}\\n\\n\"\n            \"Escolha uma op√ß√£o:\",\n            reply_markup=reply_markup,\n            parse_mode=\"Markdown\"\n        )\n        \n        return SELECIONAR_GRUPO\n    except Exception as e:\n        logger.error(f\"Error showing group management menu: {e}\")\n        await update.callback_query.edit_message_text(\"Erro ao mostrar menu. Tente novamente.\")\n        return ConversationHandler.END\n\nasync def cadastrar_novo_grupo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Start group registration process.\"\"\"\n    try:\n        if update.callback_query:\n            await update.callback_query.edit_message_text(\n                \"üìù **Cadastrar Novo Grupo**\\n\\n\"\n                \"Envie o ID do grupo ou nome do canal:\\n\\n\"\n                \"‚Ä¢ Para grupos: -100xxxxxxxxx\\n\"\n                \"‚Ä¢ Para canais: @nomecanal\\n\\n\"\n                \"üí° Dica: Adicione o bot no grupo primeiro para obter o ID correto.\"\n            )\n        else:\n            await update.message.reply_text(\n                \"üìù **Cadastrar Novo Grupo**\\n\\n\"\n                \"Envie o ID do grupo ou nome do canal:\\n\\n\"\n                \"‚Ä¢ Para grupos: -100xxxxxxxxx\\n\"\n                \"‚Ä¢ Para canais: @nomecanal\\n\\n\"\n                \"üí° Dica: Adicione o bot no grupo primeiro para obter o ID correto.\"\n            )\n        return CONFIRMAR_GRUPO\n    except Exception as e:\n        logger.error(f\"Error starting group registration: {e}\")\n        return ConversationHandler.END\n\nasync def processar_cadastro_grupo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Process group ID/name and test access.\"\"\"\n    try:\n        group_input = update.message.text.strip()\n        \n        # Validate input format\n        if not (group_input.startswith(\"-100\") or group_input.startswith(\"@\")):\n            await update.message.reply_text(\n                \"‚ùå Formato inv√°lido.\\n\\n\"\n                \"Use:\\n\"\n                \"‚Ä¢ -100xxxxxxxxx para grupos\\n\"\n                \"‚Ä¢ @nomecanal para canais\\n\\n\"\n                \"Tente novamente:\"\n            )\n            return CONFIRMAR_GRUPO\n        \n        # Test group access by sending test message\n        try:\n            if group_input.startswith(\"@\"):\n                chat_id = group_input\n            else:\n                chat_id = int(group_input)\n            \n            # Send test message\n            test_msg = await context.bot.send_message(\n                chat_id=chat_id,\n                text=\"üü¢ GRUPO ATIVADO\\n\\nEste grupo foi cadastrado com sucesso!\"\n            )\n            \n            # Initialize grupos if not exists\n            if \"grupos\" not in context.user_data:\n                context.user_data[\"grupos\"] = []\n            \n            # Store group info and automatically add to list\n            group_name = f\"Grupo {len(context.user_data['grupos']) + 1}\"\n            \n            # Check for duplicates\n            grupos_existentes = context.user_data[\"grupos\"]\n            for grupo in grupos_existentes:\n                if str(grupo[\"chat_id\"]) == str(chat_id):\n                    await update.message.reply_text(\n                        f\"‚úÖ **Grupo j√° estava cadastrado**\\n\\n\"\n                        f\"O grupo `{chat_id}` j√° existe na sua lista como '{grupo['name']}'.\",\n                        parse_mode=\"Markdown\"\n                    )\n                    # Show main menu automatically\n                    await start(update, context)\n                    return ConversationHandler.END\n            \n            # Add group to user's list automatically\n            context.user_data[\"grupos\"].append({\n                \"chat_id\": chat_id,\n                \"name\": group_name\n            })\n            \n            # Show success message\n            await update.message.reply_text(\n                f\"‚úÖ **Grupo adicionado com sucesso!**\\n\\n\"\n                f\"**Nome:** {group_name}\\n\"\n                f\"**ID:** `{chat_id}`\\n\\n\"\n                f\"Total de grupos: {len(context.user_data['grupos'])}\",\n                parse_mode=\"Markdown\"\n            )\n            \n            # Automatically show main menu\n            await start(update, context)\n            return ConversationHandler.END\n            \n        except Exception as access_error:\n            logger.error(f\"Group access test failed: {access_error}\")\n            await update.message.reply_text(\n                f\"‚ùå **N√£o foi poss√≠vel acessar o grupo**\\n\\n\"\n                f\"**ID/Nome enviado:** {group_input}\\n\\n\"\n                \"**Poss√≠veis problemas:**\\n\"\n                \"‚Ä¢ Bot n√£o foi adicionado ao grupo\\n\"\n                \"‚Ä¢ ID do grupo incorreto\\n\"\n                \"‚Ä¢ Canal privado sem permiss√£o\\n\"\n                \"‚Ä¢ Bot sem permiss√µes de envio\\n\\n\"\n                \"Verifique e tente novamente:\"\n            )\n            return CONFIRMAR_GRUPO\n            \n    except Exception as e:\n        logger.error(f\"Error processing group registration: {e}\")\n        await update.message.reply_text(\"Erro ao processar cadastro. Tente novamente.\")\n        return CONFIRMAR_GRUPO\n\nasync def mostrar_grupos_cadastrados(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Show list of registered groups.\"\"\"\n    try:\n        query = update.callback_query\n        await query.answer()\n        \n        grupos = context.user_data.get(\"grupos\", [])\n        \n        if not grupos:\n            keyboard = [\n                [InlineKeyboardButton(\"‚ûï Cadastrar primeiro grupo\", callback_data=\"cadastrar_grupo\")],\n                [InlineKeyboardButton(\"üè† Voltar ao Menu Principal\", callback_data=\"voltar_menu\")]\n            ]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await query.edit_message_text(\n                \"üìã **Grupos Cadastrados**\\n\\n\"\n                \"Nenhum grupo cadastrado ainda.\\n\\n\"\n                \"Cadastre seu primeiro grupo para come√ßar a usar o bot!\",\n                reply_markup=reply_markup,\n                parse_mode=\"Markdown\"\n            )\n        else:\n            # Build group list text\n            group_list = \"üìã **Grupos Cadastrados**\\n\\n\"\n            for i, grupo in enumerate(grupos, 1):\n                group_list += f\"{i}. **{grupo['name']}**\\n\"\n                group_list += f\"   ID: `{grupo['chat_id']}`\\n\\n\"\n            \n            # Build keyboard with group management options\n            keyboard = []\n            for i, grupo in enumerate(grupos):\n                keyboard.append([\n                    InlineKeyboardButton(f\"üóëÔ∏è Remover {grupo['name']}\", callback_data=f\"remover_grupo_{i}\")\n                ])\n            \n            keyboard.extend([\n                [InlineKeyboardButton(\"‚ûï Cadastrar novo grupo\", callback_data=\"cadastrar_grupo\")],\n                [InlineKeyboardButton(\"üîô Voltar\", callback_data=\"gerenciar_grupos\")]\n            ])\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await query.edit_message_text(\n                group_list,\n                reply_markup=reply_markup,\n                parse_mode=\"Markdown\"\n            )\n        \n        return SELECIONAR_GRUPO\n    except Exception as e:\n        logger.error(f\"Error showing registered groups: {e}\")\n        await update.callback_query.edit_message_text(\"Erro ao mostrar grupos. Tente novamente.\")\n        return ConversationHandler.END\n\nasync def mostrar_selecao_destinos(update: Update, context: ContextTypes.DEFAULT_TYPE, action_type: str) -> int:\n    \"\"\"Show destination group selection menu.\"\"\"\n    try:\n        query = update.callback_query\n        await query.answer()\n        \n        grupos = context.user_data.get(\"grupos\", [])\n        \n        if not grupos:\n            keyboard = [[InlineKeyboardButton(\"üè† Voltar ao Menu Principal\", callback_data=\"voltar_menu\")]]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await query.edit_message_text(\n                \"‚ùå **Nenhum grupo cadastrado**\\n\\n\"\n                \"Voc√™ precisa cadastrar pelo menos um grupo antes de enviar mensagens.\\n\\n\"\n                \"Use a op√ß√£o 'Gerenciar grupos' primeiro.\",\n                reply_markup=reply_markup,\n                parse_mode=\"Markdown\"\n            )\n            return ConversationHandler.END\n        \n        # Build selection menu\n        keyboard = []\n        action_text = \"enviar mensagem\" if action_type == \"envio\" else \"repassar mensagens\"\n        \n        for i, grupo in enumerate(grupos):\n            callback_data = f\"destino_{action_type}_{i}\"\n            keyboard.append([InlineKeyboardButton(f\"üì§ {grupo['name']}\", callback_data=callback_data)])\n        \n        keyboard.append([InlineKeyboardButton(\"üîô Voltar\", callback_data=\"voltar_menu\")])\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(\n            f\"üéØ **Escolha o destino**\\n\\n\"\n            f\"Para onde deseja {action_text}?\\n\\n\"\n            f\"Grupos dispon√≠veis: {len(grupos)}\",\n            reply_markup=reply_markup,\n            parse_mode=\"Markdown\"\n        )\n        \n        # Store action type for later use\n        context.user_data[\"action_type\"] = action_type\n        \n        return MENU_ENVIO if action_type == \"envio\" else RECEBER_ENCAMINHADAS\n        \n    except Exception as e:\n        logger.error(f\"Error showing destination selection: {e}\")\n        await update.callback_query.edit_message_text(\"Erro ao mostrar destinos. Tente novamente.\")\n        return ConversationHandler.END\n\n# Add handler for group registration text input\nasync def selecionar_grupo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Handle group ID input during registration.\"\"\"\n    return await processar_cadastro_grupo(update, context)\n\n# Voltar ao menu principal handler\nasync def voltar_menu_principal(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Handle return to main menu.\"\"\"\n    query = update.callback_query\n    await query.answer()\n    \n    # Clear conversation state\n    context.user_data.clear()\n    \n    # Show main menu\n    await start(update, context)\n    return ConversationHandler.END\n\n# New functions for group registration and message forwarding\n\nasync def iniciar_cadastro_grupo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Start the group registration process by listing available groups.\"\"\"\n    try:\n        # Get bot's chats/groups\n        bot_user = await context.bot.get_me()\n        \n        # Since we can't directly list all chats, we'll ask user to add bot to groups first\n        await update.callback_query.edit_message_text(\n            \"Para cadastrar um grupo de destino, primeiro adicione este bot aos grupos/canais desejados como administrador.\\n\\n\"\n            \"Depois, envie o ID do grupo ou canal que deseja usar como destino.\\n\\n\"\n            \"Formato: -100xxxxxxxxx (para supergrupos) ou @nomecanal (para canais p√∫blicos)\"\n        )\n        return SELECIONAR_GRUPO\n    except Exception as e:\n        logger.error(f\"Error starting group registration: {e}\")\n        await update.callback_query.edit_message_text(\"Erro ao iniciar cadastro. Tente novamente.\")\n        return ConversationHandler.END\n\nasync def selecionar_grupo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Handle group selection by ID or username.\"\"\"\n    try:\n        group_input = update.message.text.strip()\n        \n        # Validate and convert input\n        chat_id = None\n        if group_input.startswith(\"-\"):\n            try:\n                chat_id = int(group_input)\n            except ValueError:\n                await update.message.reply_text(\"ID de grupo inv√°lido. Use o formato: -100xxxxxxxxx\")\n                return SELECIONAR_GRUPO\n        elif group_input.startswith(\"@\"):\n            chat_id = group_input\n        else:\n            await update.message.reply_text(\n                \"Formato inv√°lido. Use:\\n\"\n                \"- ID do grupo: -100xxxxxxxxx\\n\"\n                \"- Nome do canal: @nomecanal\"\n            )\n            return SELECIONAR_GRUPO\n        \n        # Test if bot can send message to this group\n        try:\n            test_message = await context.bot.send_message(\n                chat_id=chat_id,\n                text=\"ü§ñ GRUPO ATIVADO\\n\\nEste grupo foi selecionado como destino para repassar mensagens.\"\n            )\n            \n            # Store for confirmation\n            context.user_data[\"pending_group_id\"] = chat_id\n            context.user_data[\"test_message_id\"] = test_message.message_id\n            \n            # Show confirmation menu\n            keyboard = [\n                [InlineKeyboardButton(\"‚úÖ Confirmar\", callback_data=\"confirmar_grupo\")],\n                [InlineKeyboardButton(\"üîÑ Alterar\", callback_data=\"alterar_grupo\")],\n                [InlineKeyboardButton(\"‚ùå Cancelar\", callback_data=\"cancelar_grupo\")]\n            ]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await update.message.reply_text(\n                f\"Mensagem de teste enviada para: {chat_id}\\n\\n\"\n                f\"Confirma este grupo como destino das mensagens?\",\n                reply_markup=reply_markup\n            )\n            return CONFIRMAR_GRUPO\n            \n        except Exception as e:\n            logger.error(f\"Error testing group access: {e}\")\n            await update.message.reply_text(\n                \"‚ùå N√£o foi poss√≠vel enviar mensagem para este grupo.\\n\\n\"\n                \"Verifique se:\\n\"\n                \"‚Ä¢ O bot foi adicionado ao grupo\\n\"\n                \"‚Ä¢ O bot tem permiss√£o para enviar mensagens\\n\"\n                \"‚Ä¢ O ID/nome est√° correto\\n\\n\"\n                \"Tente novamente:\"\n            )\n            return SELECIONAR_GRUPO\n            \n    except Exception as e:\n        logger.error(f\"Error in selecionar_grupo: {e}\")\n        await update.message.reply_text(\"Erro ao processar sele√ß√£o. Tente novamente.\")\n        return SELECIONAR_GRUPO\n\nasync def processar_repassar_mensagem(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Process and forward any message to the registered destination group.\"\"\"\n    try:\n        destination_group = get_destination_group()\n        if not destination_group:\n            await update.message.reply_text(\n                \"‚ùå Nenhum grupo de destino cadastrado.\\n\"\n                \"Use a op√ß√£o 'Cadastrar grupo de destino' primeiro.\"\n            )\n            return\n        \n        message = update.message\n        \n        # Copy the message to destination group preserving all content\n        try:\n            if message.photo:\n                # Photo with caption\n                await context.bot.send_photo(\n                    chat_id=destination_group,\n                    photo=message.photo[-1].file_id,\n                    caption=message.caption,\n                    caption_entities=message.caption_entities,\n                    reply_markup=message.reply_markup\n                )\n            elif message.video:\n                # Video with caption  \n                await context.bot.send_video(\n                    chat_id=destination_group,\n                    video=message.video.file_id,\n                    caption=message.caption,\n                    caption_entities=message.caption_entities,\n                    reply_markup=message.reply_markup\n                )\n            elif message.document:\n                # Document\n                await context.bot.send_document(\n                    chat_id=destination_group,\n                    document=message.document.file_id,\n                    caption=message.caption,\n                    caption_entities=message.caption_entities,\n                    reply_markup=message.reply_markup\n                )\n            elif message.audio:\n                # Audio\n                await context.bot.send_audio(\n                    chat_id=destination_group,\n                    audio=message.audio.file_id,\n                    caption=message.caption,\n                    caption_entities=message.caption_entities,\n                    reply_markup=message.reply_markup\n                )\n            elif message.voice:\n                # Voice message\n                await context.bot.send_voice(\n                    chat_id=destination_group,\n                    voice=message.voice.file_id,\n                    caption=message.caption,\n                    caption_entities=message.caption_entities,\n                    reply_markup=message.reply_markup\n                )\n            elif message.video_note:\n                # Video note (circle video)\n                await context.bot.send_video_note(\n                    chat_id=destination_group,\n                    video_note=message.video_note.file_id,\n                    reply_markup=message.reply_markup\n                )\n            elif message.sticker:\n                # Sticker\n                await context.bot.send_sticker(\n                    chat_id=destination_group,\n                    sticker=message.sticker.file_id,\n                    reply_markup=message.reply_markup\n                )\n            elif message.animation:\n                # GIF/Animation\n                await context.bot.send_animation(\n                    chat_id=destination_group,\n                    animation=message.animation.file_id,\n                    caption=message.caption,\n                    caption_entities=message.caption_entities,\n                    reply_markup=message.reply_markup\n                )\n            elif message.text:\n                # Text message\n                await context.bot.send_message(\n                    chat_id=destination_group,\n                    text=message.text,\n                    entities=message.entities,\n                    reply_markup=message.reply_markup\n                )\n            else:\n                # Fallback for other message types\n                await context.bot.copy_message(\n                    chat_id=destination_group,\n                    from_chat_id=message.chat_id,\n                    message_id=message.message_id\n                )\n            \n            # Confirm to user with return to menu option\n            keyboard = [[InlineKeyboardButton(\"üè† Voltar ao Menu Principal\", callback_data=\"voltar_menu\")]]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await update.message.reply_text(\n                \"‚úÖ Mensagem repassada com sucesso!\",\n                reply_markup=reply_markup\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error sending message to destination: {e}\")\n            await update.message.reply_text(\n                \"‚ùå Erro ao repassar mensagem.\\n\"\n                \"Verifique se o bot ainda tem acesso ao grupo de destino.\"\n            )\n            \n    except Exception as e:\n        logger.error(f\"Error in processar_repassar_mensagem: {e}\")\n        await update.message.reply_text(\"Erro ao processar mensagem.\")\n","size_bytes":47748},"utils/storage.py":{"content":"import json\nimport os\nfrom typing import Optional, Dict, Any\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n# Simple JSON file storage for bot data\nSTORAGE_FILE = \"bot_data.json\"\n\ndef load_bot_data() -> Dict[str, Any]:\n    \"\"\"Load bot data from storage file.\"\"\"\n    try:\n        if os.path.exists(STORAGE_FILE):\n            with open(STORAGE_FILE, 'r', encoding='utf-8') as f:\n                return json.load(f)\n        return {}\n    except Exception as e:\n        logger.error(f\"Error loading bot data: {e}\")\n        return {}\n\ndef save_bot_data(data: Dict[str, Any]) -> bool:\n    \"\"\"Save bot data to storage file.\"\"\"\n    try:\n        with open(STORAGE_FILE, 'w', encoding='utf-8') as f:\n            json.dump(data, f, ensure_ascii=False, indent=2)\n        return True\n    except Exception as e:\n        logger.error(f\"Error saving bot data: {e}\")\n        return False\n\ndef get_destination_group() -> Optional[int]:\n    \"\"\"Get the registered destination group ID.\"\"\"\n    data = load_bot_data()\n    return data.get(\"destination_group_id\")\n\ndef set_destination_group(group_id: int) -> bool:\n    \"\"\"Set the destination group ID.\"\"\"\n    data = load_bot_data()\n    data[\"destination_group_id\"] = group_id\n    return save_bot_data(data)\n\ndef get_user_data(user_id: int, key: str, default=None):\n    \"\"\"Get user-specific data.\"\"\"\n    data = load_bot_data()\n    return data.get(f\"user_{user_id}\", {}).get(key, default)\n\ndef set_user_data(user_id: int, key: str, value) -> bool:\n    \"\"\"Set user-specific data.\"\"\"\n    data = load_bot_data()\n    if f\"user_{user_id}\" not in data:\n        data[f\"user_{user_id}\"] = {}\n    data[f\"user_{user_id}\"][key] = value\n    return save_bot_data(data)\n\ndef get_destination_groups() -> Dict[str, int]:\n    \"\"\"Get all registered destination groups.\"\"\"\n    data = load_bot_data()\n    return data.get('destination_groups', {})\n\ndef set_destination_groups(groups_dict: Dict[str, int]) -> bool:\n    \"\"\"Set the destination groups dictionary.\"\"\"\n    data = load_bot_data()\n    data['destination_groups'] = groups_dict\n    return save_bot_data(data)\n\ndef add_destination_group(name: str, group_id: int) -> bool:\n    \"\"\"Add a new destination group.\"\"\"\n    groups = get_destination_groups()\n    groups[name] = group_id\n    return set_destination_groups(groups)\n\ndef remove_destination_group(name: str) -> bool:\n    \"\"\"Remove a destination group.\"\"\"\n    groups = get_destination_groups()\n    if name in groups:\n        del groups[name]\n        return set_destination_groups(groups)\n    return False","size_bytes":2521},"utils/validators.py":{"content":"import re\nfrom typing import List, Tuple, Optional\nimport logging\n\nlogger = logging.getLogger(__name__)\n\ndef validate_button_format(text: str) -> Optional[List[Tuple[str, str]]]:\n    \"\"\"\n    Validate and parse button format: NOME|LINK, NOME2|LINK2\n    Returns list of (name, link) tuples or None if invalid\n    \"\"\"\n    try:\n        botoes = []\n        partes = [b.strip() for b in text.split(\",\") if b.strip()]\n        \n        if not partes:\n            return None\n        \n        for parte in partes:\n            if \"|\" not in parte:\n                return None\n            \n            nome, link = parte.split(\"|\", 1)\n            nome = nome.strip()\n            link = link.strip()\n            \n            if not nome or not link:\n                return None\n            \n            # Validate URL format\n            if not is_valid_url(link):\n                return None\n            \n            botoes.append((nome, link))\n        \n        return botoes if botoes else None\n    \n    except Exception as e:\n        logger.error(f\"Error validating button format: {e}\")\n        return None\n\ndef is_valid_url(url: str) -> bool:\n    \"\"\"Check if URL is valid (basic validation).\"\"\"\n    url_pattern = re.compile(\n        r'^https?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+[A-Z]{2,6}\\.?|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    \n    return url_pattern.match(url) is not None\n\ndef validate_telegram_link(link: str) -> bool:\n    \"\"\"Validate Telegram link format.\"\"\"\n    try:\n        # Accept t.me links\n        if link.startswith(\"t.me/\"):\n            username = link.split(\"/\")[-1]\n            return is_valid_username(username)\n        \n        # Accept @username format\n        if link.startswith(\"@\"):\n            username = link[1:]\n            return is_valid_username(username)\n        \n        # Accept numeric chat IDs\n        if link.lstrip(\"-\").isdigit():\n            return True\n        \n        return False\n    \n    except Exception as e:\n        logger.error(f\"Error validating Telegram link: {e}\")\n        return False\n\ndef is_valid_username(username: str) -> bool:\n    \"\"\"Check if username follows Telegram username rules.\"\"\"\n    if not username:\n        return False\n    \n    # Telegram username rules: 5-32 characters, alphanumeric + underscore\n    # Must start with letter, can't end with underscore\n    if len(username) < 5 or len(username) > 32:\n        return False\n    \n    if not re.match(r'^[a-zA-Z][a-zA-Z0-9_]*[a-zA-Z0-9]$', username):\n        return False\n    \n    return True\n\ndef sanitize_text(text: str, max_length: int = 4096) -> str:\n    \"\"\"Sanitize text for Telegram message sending.\"\"\"\n    if not text:\n        return \"\"\n    \n    # Remove excessive whitespace\n    text = re.sub(r'\\s+', ' ', text.strip())\n    \n    # Truncate if too long\n    if len(text) > max_length:\n        text = text[:max_length-3] + \"...\"\n    \n    return text\n","size_bytes":3066}}}